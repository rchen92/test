##undo的管理模式
##undo的参数
##undo表空间的建立、删除、更改
##undo资料的查询
##undo表空间的作用
	##事务处理回退
	##事务处理恢复
	##读一致性
	##闪回数据
##大小计算
##undo的备份
##undo损坏的处理
##事务的回退和提交
#undo表空间的备份恢复
#模拟丢失，并且没有备份，有其他undo表空间



undo的作用
undo的管理模式
undo的参数
undo表空间的建立、删除、更改
undo资料的查询

#undo表空间的作用
	事务处理回退
	事务处理恢复
	读一致性
	闪回数据

SQL> alter user scott account unlock identified by scott;
SQL> conn scott/scott
SQL> select ename,sal,dbms_rowid.rowid_block_number(rowid) block#,
  2  dbms_rowid.ROWID_RELATIVE_FNO(rowid) as file#
  3  from emp
  4  where empno=7839;
ENAME		  SAL	  BLOCK#      FILE#
---------- ---------- ---------- ----------
KING		 5000	     151	  4				#得到empno=7839在4号文件的151号块里面

#undo的管理模式
	自动管理
	非自动管理（不学）
SQL> conn / as sysdba
Connected.
SQL> show parameter undo_m
NAME				     TYPE	 VALUE
------------------------------------ ----------- ------------------------------
undo_management 		     string	 AUTO

#undo的参数
SQL> show parameter undo_t
NAME				     TYPE	 VALUE
------------------------------------ ----------- ------------------------------
undo_tablespace 		     string	 UNDOTBS1
SQL> desc v$rollname;
 Name					   Null?    Type
 ----------------------------------------- -------- ----------------------------
 USN						    NUMBER
 NAME					   NOT NULL VARCHAR2(30)
SQL> select * from v$rollname;
       USN NAME
---------- ------------------------------
	 0 SYSTEM							#系统段，后面的是非系统段，非系统段最少为1个
	 1 _SYSSMU1_3780397527$
	 2 _SYSSMU2_2232571081$
	 3 _SYSSMU3_2097677531$
	 4 _SYSSMU4_1152005954$
	 5 _SYSSMU5_1527469038$
	 6 _SYSSMU6_2443381498$
	 7 _SYSSMU7_3286610060$
	 8 _SYSSMU8_2012382730$
	 9 _SYSSMU9_1424341975$
	10 _SYSSMU10_3550978943$

SQL> select segment_name,segment_type from dba_segments where segment_type like '%DEFE%';
no rows selected
SQL> alter tablespace users offline;
Tablespace altered.
SQL> select segment_name,segment_type from dba_segments where segment_type like '%DEFE%';	
SEGMENT_NAME				SEGMENT_TYPE
------------------------	------------------
1.86240						DEFERRED ROLLBACK		#当有表空间offline的时候，会在system段生成这个段，在online时会消失
SQL> alter tablespace users online;
Tablespace altered.
SQL> select segment_name,segment_type from dba_segments where segment_type like '%DEFE%';
no rows selected

SQL> show parameter undo_r
NAME				     TYPE	 VALUE
------------------------------------ ----------- ------------------------------
undo_retention			     integer	 900

#undo表空间的建立、删除、更改
	create smallfile|bigfile undo tablespace name datafile <'dir'> size <> <>;
SQL> create undo tablespace undo1 datafile '/u01/app/oracle/oradata/orcl/undo1.dbf' size 10m autoextend on;
Tablespace created.

SQL> drop tablespace undo1 including contents and datafiles;
Tablespace dropped.
SQL> show parameter undo_t
NAME				     TYPE	 VALUE
------------------------------------ ----------- ------------------------------
undo_tablespace 		     string	 UNDOTBS1
SQL> drop tablespace undotbs1;
drop tablespace undotbs1
*
ERROR at line 1:
ORA-30013: undo tablespace 'UNDOTBS1' is currently in use

SQL> create undo tablespace undo1 datafile '/u01/app/oracle/oradata/orcl/undo1.dbf' size 10m autoextend on;
Tablespace created.
SQL> alter system set undo_tablespace=undo1;
SQL> alter system set undo_tablespace=undotbs1;
SQL> drop tablespace undo1 including contents and datafiles;
SQL> alter tablespace undotbs1 rename to undotbs;
SQL> show parameter undo_t;
NAME				     TYPE	 VALUE
------------------------------------ ----------- ------------------------------
undo_tablespace 		     string	 UNDOTBS1

SQL> startup force;			#启动是能启动起来的
ORACLE instance started.
Total System Global Area  534462464 bytes
Fixed Size		    2215064 bytes
Variable Size		  406848360 bytes
Database Buffers	  121634816 bytes
Redo Buffers		    3764224 bytes
Database mounted.
Database opened.
SQL> select tablespace_name from dba_data_files;
TABLESPACE_NAME
------------------------------
USERS
UNDOTBS
SYSTEM
SYSAUX
EXAMPLE
SQL> show parameter undo_t
NAME				     TYPE	 VALUE
------------------------------------ ----------- ------------------------------
undo_tablespace 		     string	 UNDOTBS
[oracle@oracle58 dbs]$ strings spfileorcl.ora | grep undo_t
*.undo_tablespace='UNDOTBS'
SQL> alter tablespace undotbs rename to undotbs1;			
Tablespace altered.
[oracle@oracle58 dbs]$ strings spfileorcl.ora | grep undo_t
*.undo_tablespace='UNDOTBS1'			#修改默认的undo表空间的名称，改完过后还会将参数文件当中对应的undo_tablespace的名字也会修改
此时已经不需要修改下面的参数了
alter system set undo_tablespace=undotbs1;

#大小计算
	undo的大小=（undo_retention*（undo blocks per second*db block size））+db block_size

SQL> select sum(undoblks)/sum((end_time-begin_time)*10800) from v$undostat;
SUM(UNDOBLKS)/SUM((END_TIME-BEGIN_TIME)*10800)
----------------------------------------------
				    .097660224
SQL> show parameter undo_r
NAME				     TYPE	 VALUE
------------------------------------ ----------- ------------------------------
undo_retention			     integer	 900
SQL> show parameter block_s
NAME				     TYPE	 VALUE
------------------------------------ ----------- ------------------------------
db_block_size			     integer	 8192
SQL> select 8192*900*0.097660224 from dual;
8192*900*0.097660224
--------------------
	    720029.3

#undo的资料查询
v$rollstat v$rollname dba_segments dba_rollback_segs v$transaction

SQL> select tablespace_name,segment_name,file_id,status from dba_rollback_segs;			#查看所有的undo表空间的段的分配情况
TABLESPACE_NAME 	       SEGMENT_NAME			 FILE_ID STATUS
------------------------------ ------------------------------ ---------- ----------------
SYSTEM			       SYSTEM				       1 ONLINE
UNDOTBS1		       _SYSSMU1_3780397527$		       3 ONLINE
UNDOTBS1		       _SYSSMU2_2232571081$		       3 ONLINE
UNDOTBS1		       _SYSSMU3_2097677531$		       3 ONLINE
UNDOTBS1		       _SYSSMU4_1152005954$		       3 ONLINE
UNDOTBS1		       _SYSSMU5_1527469038$		       3 ONLINE
UNDOTBS1		       _SYSSMU6_2443381498$		       3 ONLINE
UNDOTBS1		       _SYSSMU7_3286610060$		       3 ONLINE
UNDOTBS1		       _SYSSMU8_2012382730$		       3 ONLINE
UNDOTBS1		       _SYSSMU9_1424341975$		       3 ONLINE
UNDOTBS1		       _SYSSMU10_3550978943$		       3 ONLINE
SQL> select * from v$rollname;		#查看当前正在使用的表空间的段的分配情况
       USN NAME
---------- ------------------------------
	 0 SYSTEM
	 1 _SYSSMU1_3780397527$
	 2 _SYSSMU2_2232571081$
	 3 _SYSSMU3_2097677531$
	 4 _SYSSMU4_1152005954$
	 5 _SYSSMU5_1527469038$
	 6 _SYSSMU6_2443381498$
	 7 _SYSSMU7_3286610060$
	 8 _SYSSMU8_2012382730$
	 9 _SYSSMU9_1424341975$
	10 _SYSSMU10_3550978943$

#查询回滚段的事务有哪些，也可以说哪个用户产生的事务，包括使用的哪个段
SQL> select s.sid,s.serial#,s.username,r.name,t.cr_get,t.phy_io,t.used_ublk,t.noundo,s.program from v$rollname r,v$transaction t,v$session s where t.addr=s.taddr and t.xidusn=r.usn order by t.cr_get,phy_io;
no rows selected			#现在没有，所以为空
再开一个窗口
[oracle@oracle ~]$ sqlplus scott/scott
SQL> update emp set sal=sal+100;

SQL> select s.sid,s.serial#,s.username,r.name,t.cr_get,t.phy_io,t.used_ublk,t.noundo,s.program from v$rollname r,v$transaction t,v$session s where t.addr=s.taddr and t.xidusn=r.usn order by t.cr_get,phy_io;
    SID   SERIAL# USERNAME		NAME				    CR_GET   PHY_IO  USED_UBLK NOU	 PROGRAM
------- --------- -----------	---------------------- ------- -------- ---------- ---	 ---------------------------
	 31		  40	    SCOTT	_SYSSMU2_2232571081$		 7		  0			 1 NO	 sqlplus@oracle58.oracle58.com (TNS V1-V3)

#如何判断undo表空间中有没有回滚段的征用
SQL> select a.name,b.gets,b.waits,(b.waits/b.gets)*100 ratio from v$rollname a,v$rollstat b where a.usn=b.usn;
NAME				     GETS      WAITS	  RATIO	
------------------------------ ---------- ---------- ----------
SYSTEM				       72	   0	      0
_SYSSMU1_3780397527$		      169	   0	      0
_SYSSMU2_2232571081$		       62	   0	      0
_SYSSMU3_2097677531$		      183	   0	      0
_SYSSMU4_1152005954$		      171	   0	      0
_SYSSMU5_1527469038$		      165	   0	      0
_SYSSMU6_2443381498$		      173	   0	      0
_SYSSMU7_3286610060$		      219	   0	      0
_SYSSMU8_2012382730$		      170	   0	      0
_SYSSMU9_1424341975$		      173	   0	      0
_SYSSMU10_3550978943$		      179	   0	      0
	#如果ratio大于2，则表示有征用现象。如果存在了征用现象，那么表空间你就需要增加undo的段。如果设置的是自动增长的方式，则没有问题。默认是自动增长的。


#undo表空间的应用：事务的回退、事务的提交、闪回数据
#undo的备份
#undo损坏的处理

#事务的回退和提交
提交事务是由DML或DDL语句提交的
事务结束：人为的结束 commit，适合DML语句
		  自动结束，DDL语句
	当你执行了insert、update、delete语句后，没有执行commit命令，但是接着执行了DDL或者DCL语句，也会结束事务
一个事务的开始，是在一个会话下产生的; 一个事务的结束，是在当前会话下自动或手动结束事务操作的时候就结束已经存在的事务了
#事务的提交
SQL> show user;
USER is "SCOTT"
SQL> update emp set sal=sal+1;
SQL> show user;
USER is "SYS"
SQL> select s.sid,s.serial#,s.username,r.name,t.cr_get,t.phy_io,t.used_ublk,t.noundo,s.program from v$rollname r,v$transaction t,v$session s where t.addr=s.taddr and t.xidusn=r.usn order by t.cr_get,phy_io;
   SID  SERIAL# USERNAME	NAME				    CR_GET   PHY_IO  USED_UBLK NOU	PROGRAM
------ -------- -----------	--------------------- -------- -------- ---------- ---	-------------------------------------------
	31	     40 SCOTT		_SYSSMU2_2232571081$		14	      0	         1 NO   sqlplus@oracle58.oracle58.com (TNS V1-V3)
SQL> show user;
USER is "SCOTT"
SQL> create table t(id number);
SQL> show user;
USER is "SYS"
SQL> select s.sid,s.serial#,s.username,r.name,t.cr_get,t.phy_io,t.used_ublk,t.noundo,s.program from v$rollname r,v$transaction t,v$session s where t.addr=s.taddr and t.xidusn=r.usn order by t.cr_get,phy_io;
no rows selected			#现在就没有事务了
#事务的回退
SQL> update emp set sal=sal+100;
14 rows updated.
SQL> savepoint s1;
Savepoint created.
SQL> delete emp where deptno=10;
3 rows deleted.
SQL> savepoint s2;
Savepoint created.
SQL> delete emp where deptno=20;
5 rows deleted.
SQL> savepoint s3;
Savepoint created.
SQL> delete emp where deptno=30;
6 rows deleted.
SQL> select * from emp;
no rows selected
	#现在需要30编号的数据
SQL> rollback to s3;
Rollback complete.
SQL> select * from emp;
     EMPNO ENAME      JOB	       MGR HIREDATE	    SAL       COMM     DEPTNO
---------- ---------- --------- ---------- --------- ---------- ---------- ----------
      7499 ALLEN      SALESMAN	      7698 20-FEB-81	   1701        300	   30
      7521 WARD       SALESMAN	      7698 22-FEB-81	   1351        500	   30
      7654 MARTIN     SALESMAN	      7698 28-SEP-81	   1351       1400	   30
      7698 BLAKE      MANAGER	      7839 01-MAY-81	   2951 		   30
      7844 TURNER     SALESMAN	      7698 08-SEP-81	   1601 	 0	   30
      7900 JAMES      CLERK	      7698 03-DEC-81	   1051 		   30
	#现在需要20和30编号的数据
SQL> rollback to s2;
Rollback complete.
SQL> select distinct deptno from emp;
    DEPTNO
----------
	30
	20
	#现在3个部门都需要
SQL> rollback to s1;
Rollback complete.
SQL> select distinct deptno from emp;
    DEPTNO
----------
	30
	20
	10
	#现在要恢复到执行update语句之前
SQL> rollback;
Rollback complete.

#闪回
SQL> delete emp;
14 rows deleted.
SQL> commit;		#现在已经执行过commit命令了，那如何恢复到delete的操作之前去。
SQL> select * from emp as of timestamp sysdate-2/1440;					#现在数据是要的数据，那么恢复
     EMPNO ENAME      JOB	       MGR HIREDATE	    SAL       COMM     DEPTNO
---------- ---------- --------- ---------- --------- ---------- ---------- ----------
      7369 SMITH      CLERK	      7902 17-DEC-80	   1001 		   20
      7499 ALLEN      SALESMAN	      7698 20-FEB-81	   1801        300	   30
      7521 WARD       SALESMAN	      7698 22-FEB-81	   1451        500	   30
      7566 JONES      MANAGER	      7839 02-APR-81	   3176 		   20
      7654 MARTIN     SALESMAN	      7698 28-SEP-81	   1451       1400	   30
      7698 BLAKE      MANAGER	      7839 01-MAY-81	   3051 		   30
      7782 CLARK      MANAGER	      7839 09-JUN-81	   2651 		   10
      7788 SCOTT      ANALYST	      7566 19-APR-87	   3201 		   20
      7839 KING       PRESIDENT 	   17-NOV-81	   5201 		   10
      7844 TURNER     SALESMAN	      7698 08-SEP-81	   1701 	 0	   30
      7876 ADAMS      CLERK	      7788 23-MAY-87	   1301 		   20

     EMPNO ENAME      JOB	       MGR HIREDATE	    SAL       COMM     DEPTNO
---------- ---------- --------- ---------- --------- ---------- ---------- ----------
      7900 JAMES      CLERK	      7698 03-DEC-81	   1151 		   30
      7902 FORD       ANALYST	      7566 03-DEC-81	   3201 		   20
      7934 MILLER     CLERK	      7782 23-JAN-82	   1501 		   10
SQL> insert into emp select * from emp as of timestamp sysdate-2/1440;

#undo表空间的备份恢复
RMAN> bakcup database;
SQL> shutdown immediate
[oracle@oracle ~]$rm /u01/app/oracle/oradata/orcl/undotbs01.dbf
SQL> startup
ORACLE instance started
...
Database mounted
ORA-01157: Cannot identify/lock data file 3 - see DBWR trace file
ORA-01110: data file 3: '/u01/app/oracle/oradata/orcl/undotbs01.dbf'
RMAN> restore tablespace undotbs1;
RMAN> recover tablespace undotbs1;
SQL> alter database datafile 3 online;
SQL> alter database open;
#如果系统中没有备份undo
	1、系统中是否存在其他的undo表空间，如果是，则修改为其他undo，把损坏的undo脱机，启动数据库到open，删除损坏的表空间并建立新的
	2、没有其他的undo表空间，使用隐藏参数让我们undo脱机，打开数据库，删除undo，建立新的undo表空间
#模拟丢失，并且没有备份，有其他undo表空间
SQL> create undo tablespace undotbs02 datafile '/u01/app/oracle/oradata/orcl/undotbs02.dbf' size 100m autoextend on;
SQL> shutdown immediate
Database closed.
Database dismounted.
ORACLE instance shut down.
SQL> ho rm /u01/app/oracle/oradata/orcl/undotbs01.dbf		
SQL> startup
ORACLE instance started.
Total System Global Area  534462464 bytes
Fixed Size		    2215064 bytes
Variable Size		  406848360 bytes
Database Buffers	  121634816 bytes
Redo Buffers		    3764224 bytes
Database mounted.
ORA-01157: cannot identify/lock data file 3 - see DBWR trace file
ORA-01110: data file 3: '/u01/app/oracle/oradata/orcl/undotbs01.dbf'
SQL> alter system set undo_tablespace=undotbs02 scope=spfile;
System altered.
SQL> shutdown immediate
ORA-01109: database not open
Database dismounted.
ORACLE instance shut down.
SQL> startup 
ORACLE instance started.
Total System Global Area  534462464 bytes
Fixed Size		    2215064 bytes
Variable Size		  406848360 bytes
Database Buffers	  121634816 bytes
Redo Buffers		    3764224 bytes
Database mounted.
ORA-01157: cannot identify/lock data file 3 - see DBWR trace file
ORA-01110: data file 3: '/u01/app/oracle/oradata/orcl/undotbs01.dbf'
SQL> alter database datafile 3 offline;
Database altered.
SQL> alter database open;
Database altered.
#恢复到之前的状态
SQL> alter tablespace undotbs1 add datafile '/u01/app/oracle/oradata/orcl/undotbs1.dbf' size 100m autoextend on;
SQL> shutdown immediate
SQL> startup mount;
SQL> alter system set undo_tablespace=undotbs1 scope=spfile;
SQL> alter database open;
#模拟undo表空间丢失，并且没有备份，也没有其他undo表空间
SQL> shutdown immediate
SQL> ho rm /u01/app/oracle/oradata/orcl/undotbs1.dbf		
SQL> startup
ORACLE instance started.
Total System Global Area  534462464 bytes
Fixed Size		    2215064 bytes
Variable Size		  406848360 bytes
Database Buffers	  121634816 bytes
Redo Buffers		    3764224 bytes
Database mounted.
ORA-01157: cannot identify/lock data file 3 - see DBWR trace file
ORA-01110: data file 3: '/u01/app/oracle/oradata/orcl/undotbs01.dbf'
SQL> select ksppinm from x$ksppi where ksppinm like '%roll%';
KSPPINM
--------------------------------------------------------------------------------
...
_offline_rollback_segments
...
SQL> alter system set "_offline_rollback_segments"=true scope=spfile;		#打开隐藏参数
SQL> alter system set undo_management=manual scope=spfile;		#设置undo手动管理
SQL> alter database datafile 3 offline;					#将损坏的undo数据文件脱机
SQL> shutdown immediate;
SQL> startup
SQL> select segment_name,status from dba_rollback_segs;
SEGMENT_NAME		       STATUS
------------------------------ ----------------
SYSTEM			       ONLINE
_SYSSMU10_2652874685$	       OFFLINE
_SYSSMU9_1358129315$	       OFFLINE
_SYSSMU8_1903095675$	       OFFLINE
_SYSSMU7_12828534$	       OFFLINE
_SYSSMU6_3527613876$	       OFFLINE
_SYSSMU5_901289878$	       OFFLINE
_SYSSMU4_2331007958$	       OFFLINE
_SYSSMU3_3547760918$	       OFFLINE
_SYSSMU2_899393198$	       OFFLINE
_SYSSMU1_1746190524$	       OFFLINE
SQL> drop tablespace undotbs1;				#删除损坏的undo，然后再建立删除的undo
SQL> create undo tablespace undotbs1 datafile '/u01/app/oracle/oradata/orcl/undotbs1.dbf' size 100m autoextend on;
SQL> alter system set undo_management=auto scope=spfile;		#还原undo_management=auto
SQL> alter system set undo_tablespace=undotbs1 scope=spfile;		#将undo恢复回去
SQL> alter system reset "_offline_rollback_segments" scope=spfile sid='*';		#取消隐参"offline_rollback_segments"
SQL> shutdown immediate;
SQL> startup

#设置undo_management=manual
#"offline_rollback_segments"=true
#将损坏的undo数据文件脱机
#SQL> shutdown immediate;
#SQL> startup
#看dba_rollback_segs中的status  损坏的表空间的段是否有recover字样，如果没有，则可以删除损坏的undo，如果有则使用 #_corrupted_rollback_segments
#删除损坏的undo，然后再建立删除的undo
#还原undo_management=auto
#取消隐参"offline_rollback_segments"
#启动数据库









