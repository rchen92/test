##使用Create Table脚本创建常规表
##估算一个表可能的大小，比如说对一个表占用多少行，想估算这个表到底占用多大的空间
##修改表中的列的名称
##对象权限概述
##使u1用户访问scott用户的emp表




oracle基本数据类型
	字符型：
		字段类型			说明											限制条件
		CHAR(n)				固定涨肚字符串（以字节为单位）					最大长度2000 bytes
		VARCHAR2(n)			可变长度的字符串（以字节为单位）				最大长度4000 bytes
		CHAR(n char)		根据字符集而定的固定长度字符串（以字符为单位）	最大长度2000 chars
		VARCHAR2(n char)	根据字符集而定的可变长度字符串（以字符为单位）	最大长度4000 chars
		注释：因为char类型总是会用空格填充使之达到一个固定宽度，无论是在表段中还是索引段中，它都会占用很大的存储空间
	要有create table和storage space的权限。
	给其他用户建表的权限：create any table

使用Create Table脚本创建常规表
	Create table schema.table_name
	(列名1 类型(长度) 列约束，
	 列名2 类型(长度) 列约束,...,列约束)
	Pctfree n
	Pctused n
	Initrans n
	Maxtrans n
	Tablespace tablespace_name
	Storage(
		Initial n
		Next n
		Pctincrease n
		Minextents n
		Maxextents n buffer_pool default|recycle|keep)
			Pctfree n：指定表的每一个数据块为Update操作所保留的空间百分比，默认为10
			Pctuser n：指定在数据库上可以重新插入数据的已使用空间最低百分比
			Initrans n：指定可同时对表所有块进行更新操作的最小的事务数
			Maxtrans n：指定可同时对表所有块进行更新操作的最大的事务数
			Tablespace tbname：将所创建的表部署到规定的表空间中去
			Initial n：指定表第一个区的大小
			Next n：指定初始扩展区的大小
			Pctincrease n：指定扩展区递增的百分比。NEXT=(1+n/100)*Old_next
			Minextents n：指定为表段分配的区数的最小值
			Maxextents n：指定为表段分配的区数的最大值
			Buffer_pool：指定默认使用哪个数据缓冲区

SQL> show user;
USER is "SCOTT"
SQL> create table ta1(id number) pctfree 0;
SQL> insert into ta1 select object_id from user_objects;
SQL> /                  
SQL> /
...
SQL> /
28672 rows created.
SQL> commit;
SQL> select distinct(dbms_rowid.rowid_block_number(rowid)) block# from ta1;
    BLOCK#
----------
       537
       544
       555
	   ...
	   601
       602
79 rows selected.
SQL> select dbms_rowid.rowid_block_number(rowid) block#,id from ta1 where rownum<3;
    BLOCK#	   ID
---------- ----------
       523	73204
       523	74644
SQL> update ta1 set id=7320 where id=73204;
SQL> select dbms_rowid.rowid_block_number(rowid) block#,id from ta1 where rownum<3;
    BLOCK#	   ID
---------- ----------
       523	 7320
       523	74644

cteate table tta1(id number) storage(buffer_pool keep);

SQL> conn / as sysdba
Connected.
SQL> show parameter db_keep_c
NAME				     TYPE	 VALUE
------------------------------------ ----------- ------------------------------
db_keep_cache_size		     big integer 0
SQL> alter system set db_keep_cache_size=20m;


估算一个表可能的大小，比如说对一个表占用多少行，想估算这个表到底占用多大的空间
#这个脚本只是模拟
[oracle@oracle58 ~]$ vim /tmp/esize.sql
set serveroutput on

DECLARE
 ub NUMBER;
 ab NUMBER;
 cl sys.create_table_cost_columns;
BEGIN
  cl := sys.create_table_cost_columns( sys.create_table_cost_colinfo('NUMBER',10),
        sys.create_table_cost_colinfo('VARCHAR2',30),
        sys.create_table_cost_colinfo('VARCHAR2',30),
        sys.create_table_cost_colinfo('DATE',NULL));

  DBMS_SPACE.CREATE_TABLE_COST('SYSTEM',cl,10000000,0,ub,ab);

  DBMS_OUTPUT.PUT_LINE('Used MB: ' || TO_CHAR(ub/1024/1024));
  DBMS_OUTPUT.PUT_LINE('Alloc MB: ' || TO_CHAR(ab/1024/1024));
END;
/

SQL> show user;
USER is "SYS"
SQL> @/tmp/esize.sql
Used MB: 504.0390625
Alloc MB: 512			#一千万行的表，四个列，大小差不多为512M左右

PL/SQL procedure successfully completed.


修改表中的列的名称
SQL> conn scott/scott
Connected.
SQL> desc ta1;
 Name					   Null?    Type
 ----------------------------------------- -------- ----------------------------
 ID						    NUMBER
	#将id 改为 tid
SQL> alter table ta1 rename column id to tid;
Table altered.
SQL> desc ta1;
 Name					   Null?    Type
 ----------------------------------------- -------- ----------------------------
 TID						    NUMBER
#当执行上面的修改列名的语句时，DML语句必须是没有在执行，必须在出现Table altered.后才能执行DML语句。如果在执行时有DML在进行，可能会造成DML语句冲突，或者是阻塞的现象，这样就会影响正常的DML操作。可以使用联机重定义的技术来修改，这样就不会造成影响。
	#将tid 改为 eid
SQL> show user;
USER is "SYS"
SQL> grant execute on dbms_redefinition to scott;
SQL> grant create any table to scott;
SQL> grant lock any table to scott;
SQL> grant create any index to scott;
SQL> grant create any trigger to scott;
SQL> conn scott/scott 
SQL> desc ta1;
 Name					   Null?    Type
 ----------------------------------------- -------- ----------------------------
 TID						    NUMBER
#先要做一下统计信息的收集，让它的行比较准确
SQL> EXEC dbms_stats.gather_table_stats('SCOTT','TA1');
PL/SQL procedure successfully completed.
SQL> create table ta1_n as select tid eid from ta1 where 0=1;		#创建一张新的表，只要表的结构
SQL> exec dbms_redefinition.can_redef_table('SCOTT','TA1');			#先进行扫描，看看在进行转化的时候，联机重定义能不能进行。
BEGIN dbms_redefinition.can_redef_table('SCOTT','TA1'); END;
*
ERROR at line 1:
ORA-12089: cannot online redefine table "SCOTT"."TA1" with no primary key		#发现表没有主键
ORA-06512: at "SYS.DBMS_REDEFINITION", line 139
ORA-06512: at "SYS.DBMS_REDEFINITION", line 1782
ORA-06512: at line 1
SQL> create table tal1 as select rownum id,tid from ta1;
SQL> drop table ta1 purge;
SQL> alter table ta1 modify(id primary key);		#现在ID是主键，把tid改为eid
SQL> desc ta1;
 Name					   Null?    Type
 ----------------------------------------- -------- ----------------------------
 ID					   NOT NULL NUMBER			
 TID						    NUMBER
SQL> create table ta1_n as select id,tid eid from ta1 where 0=1;
	#创建一张新的表，只要表的结构，等下就可以将两个表进行转换，从而达到重定义的目的
SQL> EXEC dbms_stats.gather_table_stats('SCOTT','TA1');
SQL> exec dbms_redefinition.can_redef_table('SCOTT','TA1');



SQL> begin 
  2  dbms_redefinition.start_redef_table('SCOTT','TA1','TA1_N','id id,tid eid');
  3  end;
  4  /
SQL> var num number
SQL> begin 
  2  dbms_redefinition.copy_table_dependents('SCOTT','TA1','TA1_N',dbms_redefinition.cons_orig_params,true,true,true,true,:num,true);
  3  end;
  4  /
SQL> exec dbms_redefiniton.finish_redef_table('SCOTT','TA1','TA1_N');
SQL> drop table ta1_n purge;



对象权限概述
对象权限是对某个特定对象的访问权限
不同类型的对象具有不同的对象权限
管理员、对象的拥有者以及具有with grant option选项的用户可以将对象权限授予其他人
用户对自己拥有的对象具有所有的对象权限

使u1用户访问scott用户的emp表
SQL> conn u1/u1;
Connected.
SQL> select * from scott.emp;		#u1用户访问报错
select * from scott.emp
                    *
ERROR at line 1:
ORA-00942: table or view does not exist
SQL> conn / as sysdba
SQL> select * from scott.emp;			#但是使用sys用户能够查看
     EMPNO ENAME      JOB	       MGR HIREDATE	    SAL       COMM     DEPTNO
---------- ---------- --------- ---------- --------- ---------- ---------- ----------
      7369 SMITH      CLERK	      7902 17-DEC-80	    800 		   20
      7499 ALLEN      SALESMAN	      7698 20-FEB-81	   1600        300	   30
      7521 WARD       SALESMAN	      7698 22-FEB-81	   1250        500	   30
......
      7900 JAMES      CLERK	      7698 03-DEC-81	    950 		   30
      7902 FORD       ANALYST	      7566 03-DEC-81	   3000 		   20
      7934 MILLER     CLERK	      7782 23-JAN-82	   1300 		   10
14 rows selected.
SQL> select * from scott.emp;

     EMPNO ENAME      JOB	       MGR HIREDATE	    SAL       COMM     DEPTNO
---------- ---------- --------- ---------- --------- ---------- ---------- ----------
      7369 SMITH      CLERK	      7902 17-DEC-80	    800 		   20
      7499 ALLEN      SALESMAN	      7698 20-FEB-81	   1600        300	   30
......
      7900 JAMES      CLERK	      7698 03-DEC-81	    950 		   30
      7902 FORD       ANALYST	      7566 03-DEC-81	   3000 		   20
      7934 MILLER     CLERK	      7782 23-JAN-82	   1300 		   10
14 rows selected.
SQL> select owner,table_name,privilege from user_tab_privs;
OWNER			       TABLE_NAME		      PRIVILEGE
------------------------------ ------------------------------ ----------------------------------------
SCOTT			       EMP			      SELECT


sysdba,sysoper,dba
with admin option	with grant option
grant select,insert,update on scott.emp to u1;
grant select on scott.emp to u1,u2;
u1用户只能更emp表的sal列
	grant update(sal) on scott.emp to u1;
	grant update(ename,sal) on scott.emp to u1;
SQL> conn / as sysdba
Connected.
SQL> grant update(sal) on scott.emp to u1;
SQL> conn u1/u1;
SQL> select owner,table_name,column_name,privilege from user_col_privs
OWNER		TABLE_NAME	     COLUMN_NAME	       PRIVILEGE
--------------- -------------------- ------------------------- --------------------
SCOTT		EMP		     SAL		       UPDATE








