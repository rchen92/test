##范围分区(Range partitioning)
##散列分区(Hash partitioning)
##列表分区(List partitioning)
##复合分区(Composite partitioning)
##分区维护操作
	##添加分区
	##拆分分区
	##合并分区
	##重命名分区
	##交换分区
	##移动分区
	##删除和减少分区
##复合分区：范围range--列表list





分区表的定义和类型
分区是一种方法，他将一个大表从逻辑上根据某些条件把数据分成若干个较小的且更容易干里的区――分区段（表）
分区表是一种特殊的常规表
按照分区的方式可以将分区表分为
	范围分区(Range partitioning)
		比如某个季度，某个月。between...and...
	散列分区(Hash partitioning)
		通过计算hash值，然后通过hash值来插入、查询到某个分区
	列表分区(List partitioning)
		满足于唯一值非常的少（某列的值只有几个）：比如说性别就只有男、女、保密。
	复合分区(Composite partitioning)
		复合范围-散列分区(Composite Range-Hash partitioning)
		复合范围-列表分区(Composite Range-List partitioning)

分区维护操作
	添加分区
		语法格式：ALTER TABLE 表名 ADD PARTITION 分区名;
			例：在散列分区表product尾部增加分区p3。
			ALTER TABLE product ADD PARTITION p3 tablespace users;
	拆分分区
		语法格式：ALTER TABLE 表名 SPLIT PARTITION 分区名 AT(分区列值) INTO(PARTITION 子分区1,PARTITION 子分区2);
			例：在范围分区表sales的中间增加分区
			ALTER TABLE sales SPLIT PARTITION p3 AT('01-AUG-2003') INTO(PARTITION p3_1,PARTITION p3_2);
	合并分区
		语法格式：ALTER TABLE 表名 MERGE PARTITION 子分区名 INTO PARTITION 分区名;
			例：将sales表分区p3_1,p3_2合并成一个分区p3
			ALTER TABLE sales MERGE PARTITIONS p3_1,p3_2 INTO PARTITION p3;
	重命名分区
		语法格式：ALTER TABLE 表名 RENAME PARTITION 旧名 TO 新名;
			例：将sales表分区p3更名为p3_1
			ALTER TABLE sales RENAME PARTITION p3 TO p3_1;
	删除分区
		语法格式1：ALTER TABLE 表名 DROP PARTITION 分区名;		#删除分区
		语法格式2：ALTER TABLE 表名 TRUNCATE PARTITION 分区名;	#删除分区表里面的数据
			例：将sales表分区p3_1中的数据删除掉
			ALTER TABLE sales TRUNCATE PARTITION p3_1;
	交换分区
		语法格式1：ALTER TABLE 分区表 EXCHANGE PARTITION 分区名 WITH TABLE 常规表;
			例：将sales表p1分区中的数据导入到同结构的常规表sales_1表中：模拟故障删除p1分区中的数据，然后将sales_1表中的数据还原到sales表的p1区中
			CREATE TABLE sales_1 (同结构选项,...);
			INSERT INTO sales_1 SELECT * FROM sales PARTITION(p1);
			ALTER TABLE sales TRUNCATE PARTITION p1;
			ALTER TABLE sales EXCHANGE PARTITION p1 WITH TABLE sales_1;  #现在就是将sales_1中的数据分区交换到sales的p1分区中
	移动分区
		语法格式：ALTER TABLE sales MOVE PARTITION p1 TABLESPACE 其他表空间;	#将p1分区移动到其他表空间存储

分区表：为了简化数据库大表的管理，例如在数据仓库中一般都是TB级的数量级。分区现在可以将表分离在若干不同的表空间上，用分而治之的方法来支撑无限膨胀的大表，提高大表在物理一级的可管理性。将大表分割成较小的分区可以改善表的维护、备份、恢复、事务以及查询性能。
分区的有点：
	增强可用性
	减少关闭时间
	维护轻松
	均衡I/O
	改善性能
	分区对用户透明


#范围分区
#将emp表的员工入职时间，按每年一个分区进行划分
SQL> conn scott/scott;
SQL> select to_char(hiredate,'yyyy-mm-dd') hiredate from emp;
HIREDATE
----------
1980-12-17
1981-02-20
1981-02-22
1981-04-02
1981-09-28
1981-05-01
1981-06-09
1987-04-19
1981-11-17
1981-09-08
1987-05-23
1981-12-03
1981-12-03
1982-01-23
14 rows selected.
#现在有80年，81年，82年，87年的，...
	80放在d1，81放在d2，82放在都d3，97放在d4，其他的放在d5表分区
SQL> conn / as sysdba
SQL> create tablespace d1 datafile '/u01/app/oracle/oradata/orcl/d101.dbf' size 50m;
SQL> create tablespace d2 datafile '/u01/app/oracle/oradata/orcl/d201.dbf' size 50m;
SQL> create tablespace d3 datafile '/u01/app/oracle/oradata/orcl/d301.dbf' size 50m;
SQL> create tablespace d4 datafile '/u01/app/oracle/oradata/orcl/d401.dbf' size 50m;
SQL> create tablespace d5 datafile '/u01/app/oracle/oradata/orcl/d501.dbf' size 50m;
SQL> conn scott/scott
SQL> desc emp
 Name								   Null?    Type
 ----------------------------------------------------------------- -------- --------------------------------------------
 EMPNO								   NOT NULL NUMBER(4)
 ENAME									    VARCHAR2(10)
 JOB									    VARCHAR2(9)
 MGR									    NUMBER(4)
 HIREDATE								    DATE
 SAL									    NUMBER(7,2)
 COMM									    NUMBER(7,2)
 DEPTNO 								    NUMBER(2)
SQL> create table emprange(empno number(4) primary key,ename varchar2(10),job varchar2(9),mgr number(4),hiredate date,sal number(7,2),comm number(7,2),deptno number(2))
  2  partition by range(hiredate)
  3  (
  4   partition emprange_p1 values less than(to_date('1981-01-01','yyyy-mm-dd')) tablespace d1,
  5   partition emprange_p2 values less than(to_date('1982-01-01','yyyy-mm-dd')) tablespace d2,
  6   partition emprange_p3 values less than(to_date('1983-01-01','yyyy-mm-dd')) tablespace d3,
  7   partition emprange_p4 values less than(to_date('1988-01-01','yyyy-mm-dd')) tablespace d4,
  8   partition emprange_p5 values less than(maxvalue) tablespace d5
  9  );
Table created.
SQL> desc emprange;
 Name								   Null?    Type
 ----------------------------------------------------------------- -------- --------------------------------------------
 EMPNO								   NOT NULL NUMBER(4)
 ENAME									    VARCHAR2(10)
 JOB									    VARCHAR2(9)
 MGR									    NUMBER(4)
 HIREDATE								    DATE
 SAL									    NUMBER(7,2)
 COMM									    NUMBER(7,2)
 DEPTNO 								    NUMBER(2)
SQL> insert into emprange select * from emp;
SQL> select table_name,partition_name from user_tab_partitions where table_name='EMPRANGE';
TABLE_NAME	     PARTITION_NAME
-------------------- ------------------------------
EMPRANGE	     EMPRANGE_P1
EMPRANGE	     EMPRANGE_P2
EMPRANGE	     EMPRANGE_P3
EMPRANGE	     EMPRANGE_P4
EMPRANGE	     EMPRANGE_P5
SQL> select to_char(hiredate,'yyyy-mm-dd') hiredate from emprange partition(emprange_p1);		#现在就能按照分区来查询
HIREDATE
----------
1980-12-17
SQL> select to_char(hiredate,'yyyy-mm-dd') hiredate from emprange partition(emprange_p2);
HIREDATE
----------
1981-02-20
1981-02-22
1981-04-02
1981-09-28
1981-05-01
1981-06-09
1981-11-17
1981-09-08
1981-12-03
1981-12-03
SQL> select to_char(hiredate,'yyyy-mm-dd') hiredate from emprange partition(emprange_p3);
HIREDATE
----------
1982-01-23
SQL> select to_char(hiredate,'yyyy-mm-dd') hiredate from emprange partition(emprange_p4);
HIREDATE
----------
1987-04-19
1987-05-23
SQL> select to_char(hiredate,'yyyy-mm-dd') hiredate from emprange partition(emprange_p5);
no rows selected
SQL> insert into emprange(empno,hiredate) values(10,to_date('1985-03-01','yyyy-mm-dd'));
SQL> select to_char(hiredate,'yyyy-mm-dd') hiredate from emprange partition(emprange_p4);
HIREDATE
----------
1987-04-19
1987-05-23
1985-03-01
SQL> select table_name,partition_name,tablespace_name from user_tab_partitions where table_name='EMPRANGE';
TABLE_NAME	     PARTITION_NAME		    TABLESPACE_NAME
-------------------- ------------------------------ ------------------------------
EMPRANGE	     EMPRANGE_P1		    D1
EMPRANGE	     EMPRANGE_P2		    D2
EMPRANGE	     EMPRANGE_P3		    D3
EMPRANGE	     EMPRANGE_P4		    D4
EMPRANGE	     EMPRANGE_P5		    D5
#在此基础上增加、删除分区
#现在让88年的在第5个分区，之后的都在users表空间分区，动的时候要动最后一个分区，然后在增加。不过需要先查看最后一个分区有没有数据，没有数据则可以删除，有数据则需要先备出来。
SQL> select count(*) from emprange partition(emprange_p5);
  COUNT(*)
----------
	 0
SQL> alter table emprange drop partition emprange_p5;
SQL> alter table emprange add partition emprange_p5 values less than(to_date('1989-01-01','yyyy-mm-dd')) tablespace d5;
SQL> alter table emprange add partition emprange_p6 values less than(maxvalue) tablespace users;


#列表分区
emp下的deptno有10、20、30
10放在d1，20放在d2，30放在d3
SQL> create table emplist(empno number(4) primary key,ename varchar2(10),job varchar2(9),mgr number(4),hiredate date,sal number(7,2),comm number(7,2),deptno number(2))
  2  partition by list(deptno)
  3  (
  4   partition emplist_p1 values(10) tablespace d1,
  5   partition emplist_p2 values(20) tablespace d2,
  6   partition emplist_p3 values(30) tablespace d3,
  7   partition emplist_p4 values(40) tablespace d4,
  8   partition emplist_p5 values(default) tablespace d5
  9  );
Table created.
SQL> desc emplist
 Name								   Null?    Type
 ----------------------------------------------------------------- -------- --------------------------------------------
 EMPNO								   NOT NULL NUMBER(4)
 ENAME									    VARCHAR2(10)
 JOB									    VARCHAR2(9)
 MGR									    NUMBER(4)
 HIREDATE								    DATE
 SAL									    NUMBER(7,2)
 COMM									    NUMBER(7,2)
 DEPTNO 								    NUMBER(2)
SQL> insert into emplist select * from emp;
SQL> select table_name,partition_name,tablespace_name from user_tab_partitions where table_name='EMPLIST';
TABLE_NAME	     PARTITION_NAME		    TABLESPACE_NAME
-------------------- ------------------------------ ------------------------------
EMPLIST 	     EMPLIST_P1 		    D1
EMPLIST 	     EMPLIST_P2 		    D2
EMPLIST 	     EMPLIST_P3 		    D3
EMPLIST 	     EMPLIST_P4 		    D4
EMPLIST 	     EMPLIST_P5 		    D5
SQL> select deptno from emplist partition(emplist_p1);
    DEPTNO
----------
	10
	10
	10
SQL> select deptno from emplist partition(emplist_p2);
    DEPTNO
----------
	20
	20
	20
	20
	20
SQL> select deptno from emplist partition(emplist_p3);
    DEPTNO
----------
	30
	30
	30
	30
	30
	30
SQL> select deptno from emplist partition(emplist_p4);
no rows selected
SQL> select deptno from emplist partition(emplist_p5);
no rows selected
#删除和减少分区			#同样，分区表里面必须没有数据
SQL> alter table emplist drop partition emplist_p4;
SQL> alter table emplist drop partition emplist_p5;
SQL> alter table emplist add partition emplist_p4 values(default) tablespace d4;


#散列分区（Hash分区）
#将ename按照hash来分，这个没有什么规律
SQL> create table emphash(empno number(4) primary key,ename varchar2(10),job varchar2(9),mgr number(4),hiredate date,sal number(7,2),comm number(7,2),deptno number(2))
  2  partition by hash(ename)
  3  (
  4   partition emphash_p1 tablespace d1,
  5   partition emphash_p2 tablespace d2,
  6   partition emphash_p3 tablespace d3
  7  );
SQL> desc emphash
 Name								   Null?    Type
 ----------------------------------------------------------------- -------- --------------------------------------------
 EMPNO								   NOT NULL NUMBER(4)
 ENAME									    VARCHAR2(10)
 JOB									    VARCHAR2(9)
 MGR									    NUMBER(4)
 HIREDATE								    DATE
 SAL									    NUMBER(7,2)
 COMM									    NUMBER(7,2)
 DEPTNO 								    NUMBER(2)
SQL> insert into emphash select * from emp;
SQL> select table_name,partition_name,tablespace_name from user_tab_partitions where table_name='EMPHASH';
TABLE_NAME	     PARTITION_NAME		    TABLESPACE_NAME
-------------------- ------------------------------ ------------------------------
EMPHASH 	     EMPHASH_P1 		    D1
EMPHASH 	     EMPHASH_P2 		    D2
EMPHASH 	     EMPHASH_P3 		    D3
SQL> select ename from emphash partition(emphash_p1);
ENAME
----------
ALLEN
MARTIN
BLAKE
ADAMS
MILLER
SQL> select ename from emphash partition(emphash_p2);
ENAME
----------
SMITH
JONES
CLARK
SCOTT
KING
FORD
SQL> select ename from emphash partition(emphash_p3);
ENAME
----------
WARD
TURNER
JAMES


#复合分区：范围range--列表list
#先做hiredate是range分区，在这个基础上然后再让deptno是list分区
SQL> create table emprl(empno number(4) primary key,ename varchar2(10),job varchar2(9),mgr number(4),hiredate date,sal number(7,2),comm number(7,2),deptno number(2))
  2  partition by range(hiredate)
  3  subpartition by list(deptno)
  4  (
  5    partition emprl_p1 values less than(to_date('1981-01-01','yyyy-mm-dd')) tablespace d1
  6    (
  7      subpartition emprl_p1_1 values(10),
  8      subpartition emprl_p1_2 values(20),
  9      subpartition emprl_p1_3 values(30),
 10      subpartition emprl_p1_4 values(default)
 11    ),
 12    partition emprl_p2 values less than(to_date('1982-01-01','yyyy-mm-dd')) tablespace d2  
 13    (
 14      subpartition emprl_p2_1 values(10),
 15      subpartition emprl_p2_2 values(20),
 16      subpartition emprl_p2_3 values(30),
 17      subpartition emprl_p2_4 values(default)
 18    ),
 19    partition emprl_p3 values less than(to_date('1983-01-01','yyyy-mm-dd')) tablespace d3
 20    (
 21      subpartition emprl_p3_1 values(10),
 22      subpartition emprl_p3_2 values(20),
 23      subpartition emprl_p3_3 values(30),
 24      subpartition emprl_p3_4 values(default)
 25    ),
 26    partition emprl_p4 values less than(to_date('1988-01-01','yyyy-mm-dd')) tablespace d4
 27    (
 28      subpartition emprl_p4_1 values(10),
 29      subpartition emprl_p4_2 values(20),
 30      subpartition emprl_p4_3 values(30),
 31      subpartition emprl_p4_4 values(default)
 32    ),
 33    partition emprl_p5 values less than(maxvalue) tablespace d5
 34    (
 35      subpartition emprl_p5_1 values(10),
 36      subpartition emprl_p5_2 values(20),
 37      subpartition emprl_p5_3 values(30),
 38      subpartition emprl_p5_4 values(default)
 39    )
 40  );
Table created.
SQL> desc emprl
 Name								   Null?    Type
 ----------------------------------------------------------------- -------- --------------------------------------------
 EMPNO								   NOT NULL NUMBER(4)
 ENAME									    VARCHAR2(10)
 JOB									    VARCHAR2(9)
 MGR									    NUMBER(4)
 HIREDATE								    DATE
 SAL									    NUMBER(7,2)
 COMM									    NUMBER(7,2)
 DEPTNO 								    NUMBER(2)
SQL> select table_name,partition_name,subpartition_name,tablespace_name from user_tab_subpartitions where table_name='EMPRL';
TABLE_NAME	     PARTITION_NAME		    SUBPARTITION_NAME		   TABLESPACE_NAME
-------------------- ------------------------------ ------------------------------ ------------------------------
EMPRL		     EMPRL_P1			    EMPRL_P1_1			   D1
EMPRL		     EMPRL_P1			    EMPRL_P1_2			   D1
EMPRL		     EMPRL_P1			    EMPRL_P1_3			   D1
EMPRL		     EMPRL_P1			    EMPRL_P1_4			   D1
EMPRL		     EMPRL_P2			    EMPRL_P2_1			   D2
EMPRL		     EMPRL_P2			    EMPRL_P2_2			   D2
EMPRL		     EMPRL_P2			    EMPRL_P2_3			   D2
EMPRL		     EMPRL_P2			    EMPRL_P2_4			   D2
EMPRL		     EMPRL_P3			    EMPRL_P3_1			   D3
EMPRL		     EMPRL_P3			    EMPRL_P3_2			   D3
EMPRL		     EMPRL_P3			    EMPRL_P3_3			   D3
EMPRL		     EMPRL_P3			    EMPRL_P3_4			   D3
EMPRL		     EMPRL_P4			    EMPRL_P4_1			   D4
EMPRL		     EMPRL_P4			    EMPRL_P4_2			   D4
EMPRL		     EMPRL_P4			    EMPRL_P4_3			   D4
EMPRL		     EMPRL_P4			    EMPRL_P4_4			   D4
EMPRL		     EMPRL_P5			    EMPRL_P5_1			   D5
EMPRL		     EMPRL_P5			    EMPRL_P5_2			   D5
EMPRL		     EMPRL_P5			    EMPRL_P5_3			   D5
EMPRL		     EMPRL_P5			    EMPRL_P5_4			   D5
20 rows selected.
SQL> insert into emprl select * from emp;
SQL> select hiredate,deptno from emprl subpartition(emprl_p1_1);
no rows selected
SQL> select hiredate,deptno from emprl subpartition(emprl_p1_2);
HIREDATE      DEPTNO
--------- ----------
17-DEC-80	  20
SQL> select hiredate,deptno from emprl subpartition(emprl_p2_3);
HIREDATE      DEPTNO
--------- ----------
20-FEB-81	  30
22-FEB-81	  30
28-SEP-81	  30
01-MAY-81	  30
08-SEP-81	  30
03-DEC-81	  30























