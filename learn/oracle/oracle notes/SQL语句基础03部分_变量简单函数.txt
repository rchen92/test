#分解学习
#1、函数
#2、子查询
#3、分组汇总
#4、多表查询
#5、非标准写法


----------------------
#函数
#两种函数：
	单行函数
	多行函数

	常用的单行函数：
		字符，日期，数字，通用，转换
	
	character functions		字符函数
	a case-conversion functions		大小写转换
	lower	所有变小写
	upper	所有变大写
	initcap		首字母大写
------------------------------------
#upper
	SQL> SELECT ename,sal
	  2  FROM emp
	  3  WHERE upper(ename)=upper('&name');	  #先将ename这一列的姓名全变为大写，然后在输入时，将输入的姓名变为大写。都是大写，就能匹配
	Enter value for name: xiaohong
	old   3: WHERE upper(ename)=upper('&name')
	new   3: WHERE upper(ename)=upper('xiaohong')
	ENAME			  SAL
	---------- ----------
	Xiaohong		 5000
	SQL> /
	Enter value for name: smith
	old   3: WHERE upper(ename)=upper('&name')
	new   3: WHERE upper(ename)=upper('smith')
	ENAME			  SAL
	---------- ----------
	SMITH			  800

#例子：插入数据，但是要求员工的姓名一定大写
	INSERT into emp (empno,ename,sal) values(&no,upper('&name'),&sal)

#通过姓名查找员工的编号，工资，部门编号。要求；姓名不区分大小写
	SELECT empno,ename,sal,dept
	FROM emp
	WHERE upper(ename)=upper('&name');

---------------------------------------------
#字符操作函数
#CONCAT 字符连接
#语法：SELECT concat('char','char') FROM DUAL;
	concat('Hello','World')	--->  HelloWorld
-------------------------------------------
#例子：显示格式为scott_7788
				 ename_empno
	SQL> SELECT concat(ename,'_',empno) FROM emp;
	SELECT concat(ename,'_',empno) FROM emp			#报错了
		   *
	ERROR at line 1:
	ORA-00909: invalid number of arguments
	#刚刚里面有两个逗号，而concat的规则是嵌套，即一个逗号用一个concat，如果里面还有第二个逗号，则在里面嵌套一个concat，如果还有则再嵌套
	#正确的写法：
	SQL> SELECT concat(concat(ename,'_'),empno) FROM emp
	CONCAT(CONCAT(ENAME,'_'),EMPNO)
	-----------------------------------
	Xiaohong_99
	SMITH_7369
	ALLEN_7499
	WARD_7521
	JONES_7566

	SQL> SELECT concat(concat(concat(concat(ename,'_'),empno),'_'),deptno) FROM emp		
	CONCAT(CONCAT(CONCAT(CONCAT(ENAME,'_'),EMPNO),'_'),DEPTNO)
	--------------------------------------------------------------------------------
	Xiaohong_99_10
	SMITH_7369_20
	ALLEN_7499_30
	WARD_7521_30
	JONES_7566_20
#如果太多，这种就太麻烦了
#所以字符连接可以使用||
	SQL> SELECT ename||'_'||empno FROM emp
	ENAME||'_'||EMPNO
	----------------------------
	Xiaohong_99
	SMITH_7369
	ALLEN_7499
	WARD_7521
	JONES_7566
	SQL> SELECT ename||'_'||empno||'_'||deptno FROM emp
	ENAME||'_'||EMPNO||'_'||DEPTNO
	------------------------------------------
	Xiaohong_99_10
	SMITH_7369_20
	ALLEN_7499_30
	WARD_7521_30
	JONES_7566_20

-------------------------------
#SUBSTR 截取
#语法：SUBSTR('字符串',起始位置,截取多少位)	
	起始位置为正数	从左往右第几个
			为负数	从右往左第几个
	截取多少位	从起始位置开始向右数多少位
				如果不输入，则表示从起始位置向右到结尾
				#如果为负数，则显示为空
		SUBSTR('Hello World',1,5)	--->	Hello
				从第1位(H)开始，截取5个字符
		SUBSTR('Hello World',2,6)	--->	ello W
				从第2位(H)开始，截取6个字符
		SUBSTR('Hello World',-2,6)	--->	ld
				从倒数第2位(l)开始，截取6个字符，但是到d之后就没有了，所以不显示
		SUBSTR('Hello World',-4,6)	--->	orld
				从倒数第4位(o)开始，截取6个字符
---------------------------------------------------
	SQL> SELECT substr('Hello World',1,5) FROM DUAL;
	SUBST
	-----
	Hello
	SQL> SELECT substr('Hello World',2,6) FROM DUAL;
	SUBSTR
	------
	ello W
	SQL> SELECT substr('Hello World',-2,6) FROM DUAL
	SU
	--
	ld
	SQL> SELECT substr('Hello World',-4,6) FROM DUAL
	SUBS
	----
	SQL> SELECT substr('Hello World',3) FROM DUAL
	SUBSTR('H
	---------
	llo World
	orld
	SQL> SELECT substr('Hello World',-4,-6) FROM DUAL
	S
	-

------------------------
#LENGTH		求长度
#语法：length('字段名')
		length('HelloWorld')	--->  10
	SQL> SELECT length('Hello World') FROM DUAL;	#上面的没有空格，这里有空格
	LENGTH('HELLOWORLD')
	--------------------
					  11

-------------------------
#INSTR		定位
#语法：instr('字段名')
	从字符串的左边开始数，找第一个W的位置，然后结束
		inster('HelloWorld','W')	---> 6
	SQL> SELECT instr('HelloWorld','W') FROM DUAL;
	INSTR('HELLOWORLD','W')
	-----------------------
						  6

------------------------
#LPAD | RPAD	左右补齐
#语法：SELECT ename,lpad(字段名,长度,'填充的字符串') FROM 表;
	l ---> left
	r ---> right
		lpad(salary,10,'*')
		#先找salary的字段值长度，如果小于10，则在左边用*填充
------------------------
#例子：规定工资长度是10位，不够的在左边用0填充
	SQL> SELECT ename,sal FROM emp;
	ENAME		  SAL
	---------- ----------
	Xiaohong	 5000
	SMITH		  800
	ALLEN		 1600
	WARD		 1250
	JONES		 2975
	SQL> SELECT ename,lpad(sal,10,'*') FROM emp;
	ENAME	   LPAD(SAL,10,'*')
	---------- --------------------
	Xiaohong   ******5000
	SMITH	   *******800
	ALLEN	   ******1600
	WARD	   ******1250
	JONES	   ******2975
	SQL> SELECT ename,lpad(sal,10,'*') sal FROM emp;
	ENAME	   SAL
	---------- --------------------
	Xiaohong   ******5000
	SMITH	   *******800
	ALLEN	   ******1600
	WARD	   ******1250
	JONES	   ******2975

	SQL> SELECT ename,sal,lpad(sal,3,0) FROM emp;
	ENAME			  SAL LPAD(S
	---------- ---------- ------
	Xiaohong		 5000	 500
	SMITH			  800	 800
	ALLEN			 1600	 160
	WARD			 1250	 125
	JONES			 2975	 297
	#这下完了，数据丢失，工资少了10倍。所以以后在企业里面做数据库一定要小心

--------------------------
#REPLACE	查找替换
#语法：replace('字符串1','字符串2','字符串3')
	在 字符串1 中找 字符串2 ，然后替换为 字符串3
		REPLACE('JACK and JUE','J','BL')	--->	BLACK and BLUE
----------------------
#例子：把姓名中包含o|O全部替换为AAA
	SQL> SELECT replace(upper(ename),'O','AAA') FROM emp;
	REPLACE(UPPER(ENAME),'O','AAA'
	------------------------------
	XIAAAAHAAANG
	SMITH
	ALLEN
	WARD
	JAAANES

---------------------
#TRIM	去掉首尾空格或者符号
#例子
	SQL> SELECT '    Hello World     ' FROM DUAL;
	'HELLOWORLD'
	--------------------
		Hello World  
	SQL> SELECT trim('    Hello World     ') FROM DUAL;
	TRIM('HELLO
	-----------
	Hello World
	SQL> SELECT trim('i' FROM 'iiihihello worldiiiiii') FROM DUAL;
	TRIM('I'FROM'
	-------------
	hihello world

-------------------
#数字函数
#round		四舍五入
#trunc		截断
#mod		求余数

--------------
#round(数字,精度)
#精度表示法：
	 1  2 3 . 4 5 6
	-2 -1 0   1 2 3
	0表示个位，-1表示十位，-2表示百位，1表示小数点后一位，2表示小数点后两位，3表示小数点后三位
----------------------------
#例如
	SQL> SELECT round(45.926,2) FROM DUAL;
	ROUND(45.926,2)
	---------------
			  45.93
	SQL> SELECT round(45.9264,3) FROM DUAL;
	ROUND(45.9264,3)
	----------------
			  45.926
	SQL> SELECT round(45.9264,-1) FROM DUAL
	ROUND(45.9264,-1)
	-----------------
				   50
	SQL> SELECT round(45.9264,-2) FROM DUAL
	ROUND(45.9264,-2)
	-----------------
					0
	SQL> SELECT round(45.9264) FROM DUAL		#不写精度，默认为0
	ROUND(45.9264)
	--------------
				46

-----------------------
#日期函数
#date	数据类型

century		21	世纪
year		16	年
month		3	月
day			17	日
hours		16	小时
minutes		30	分钟
seconds		35	秒

默认格式为DD-MON-RR，但是一般不建议用这个格式

------------------
	#建立一个表
		drop table xs purge;
		create table xs (id number,ruxue date);
		1 1998-9-1
		2 2008-9-1
		3 2018-9-1
	
	SQL> CREATE TABLE xs (id number,ruxue date);
	Table created.

	#要求向学生表中插入
		1 1998-9-1
		2 2008-9-1
		3 2018-9-1
	#默认的是DD-MON-RR
		insert into xs(id,ruxue) values(1,'1-SEP-98');
		insert into xs(id,ruxue) values(2,'1-SEP-08');
		insert into xs(id,ruxue) values(3,'1-SEP-18');
		commit;

	SQL> insert into xs(id,ruxue) values(1,'1-SEP-98');
		insert into xs(id,ruxue) values(2,'1-SEP-08');
		insert into xs(id,ruxue) values(3,'1-SEP-18');
		commit;
	1 row created.
	SQL> 
	1 row created.
	SQL> 
	1 row created.
	SQL> SELECT * FROM xs;		#但是这种看不出来是1998/2098/...，1908/2008/...，1918/2018...
		ID RUXUE
	---------- ---------
		 1 01-SEP-98
		 2 01-SEP-08
		 3 01-SEP-18
	#修改一下格式
	SQL> SELECT id,to_char(ruxue,'yyyy-mm-dd') FROM xs;
			ID TO_CHAR(RU
	---------- ----------
			1  1998-09-01
			2  2008-09-01
			3  2018-09-01

	#4 1908年怎么输入
		insert into xs (id,ruxue) values(4,'1-SEP-08');
	SQL> INSERT INTO xs (id,ruxue) values(4,'1-SEP-08');
	1 row created.
	SQL> SELECT id,to_char(ruxue,'yyyy-mm-dd') FROM xs;
		ID TO_CHAR(RU
	---------- ----------
		 1 1998-09-01
		 2 2008-09-01
		 3 2018-09-01
		 4 2008-09-01		#我想输入的是1908，但最后却是2008

-----------------
#这个一定要理解明白
#有当前世纪和输入世纪两个概念，还有前半个世纪（00-49）和后半个世纪（50-99）
	#现在是2016年，是当前世纪21世纪的前半个世纪。如果我输入的年数的时间是在前半个世纪，那么最后存进去的就是当前半个世纪的年数。如果我输入的年数的时间是在后半个世纪，那么最后存进去的是20世纪的后半个世纪的年数
	#如果现在的世纪是21世纪的后半个世纪。并且如果我输入的年数的时间在前半个世纪，那么最后存进去的是下一个世纪22世纪的年数。如果我输入的年数的时间是在后半个世纪，那么最后存进去的是21世纪的后半个世纪的年数

	#所以想输入1908年，则
		insert into xs (id,ruxue) values(5,to_date('1908-9-1','yyyy-mm-dd'));
	SQL> INSERT INTO xs (id,ruxue) values(5,to_date('1908-9-1','yyyy-mm-dd'));
	1 row created.
	SQL> SELECT id,to_char(ruxue,'yyyy-mm-dd') FROM xs;
			ID TO_CHAR(RU
	---------- ----------
			 1 1998-09-01
			 2 2008-09-01
			 3 2018-09-01
			 4 2008-09-01
			 5 1908-09-01
	SQL> SELECT * FROM xs;		#但是这种就看不出来哪个是1908年了，
			ID RUXUE
	---------- ---------
			 1 01-SEP-98
			 2 01-SEP-08
			 3 01-SEP-18
			 4 01-SEP-08
			 5 01-SEP-08

#输入时间to_date('日期','日期格式')
#显示时间to_char(字符,'日期格式')

--------------------
#SYSDATE	显示系统当前时间
	SQL> SELECT sysdate FROM DUAL;
	SYSDATE
	---------
	17-MAR-16
	SQL> SELECT to_char(sysdate,'yyyy-mm-dd') FROM DUAL;
	TO_CHAR(SY
	----------
	2016-03-17
	SQL> SELECT to_char(sysdate,'yyyy-mm-dd hh:mi:ss') FROM DUAL;
	TO_CHAR(SYSDATE,'YY
	-------------------
	2016-03-17 09:48:45			#这种看不出来是上午还是下午
	SQL> SELECT to_char(sysdate,'yyyy-mm-dd hh24:mi:ss') FROM DUAL;
	TO_CHAR(SYSDATE,'YY
	-------------------
	2016-03-17 21:49:21

------------------
#日期和时间也可以参加运算
#日期可以加上或减掉一个数字，结果还是日期。两个日期之间还可以做减法
-----------------
#1天后
	SQL> ed
	SELECT to_char(sysdate+1,'yyyy-mm-dd hh24:mi:ss') FROM DUAL
	/
	SQL> /
	TO_CHAR(SYSDATE+1,'
	-------------------
	2016-03-18 21:55:55			#时间变为了3月18号
#3分钟前
	SQL> SELECT to_char(sysdate,'yyyy-mm-dd hh24:mi:ss') FROM DUAL;
	TO_CHAR(SYSDATE,'YY
	-------------------
	2016-03-17 22:07:00
	SQL> SELECT to_char(sysdate-3/1440,'yyyy-mm-dd hh24:mi:ss') FROM DUAL;
	TO_CHAR(SYSDATE-3/1
	-------------------
	2016-03-17 22:04:10
#10分钟后
	SQL> SELECT to_char(sysdate,'yyyy-mm-dd hh24:mi:ss') FROM DUAL
	TO_CHAR(SYSDATE,'YY
	-------------------
	2016-03-17 22:08:50
	SQL> SELECT to_char(sysdate+10/1440,'yyyy-mm-dd hh24:mi:ss') FROM DUAL
	TO_CHAR(SYSDATE+10/
	-------------------
	2016-03-17 22:19:01
#1个小时后
	SQL> SELECT to_char(sysdate+1/24,'yyyy-mm-dd hh24:mi:ss') FROM DUAL
	TO_CHAR(SYSDATE+1/2
	-------------------
	2016-03-17 23:10:51

-----------------
#日期操作函数
#MONTHS_BETWEEN		相隔多少个月
#ADD_MONTHS			添加几个月

#NEXT_DAY			下一个星期几是几月几号
#语法：NEXT_DAY (日期,星期几)
	NEXT_DAY ('01-SEP-95','FRIDAY')

	英文拼写			数字表示
	Monday		星期一	2
	Tuesday		星期二	3
	Wednesday	星期三	4
	Thursday	星期四	5
	Friday		星期五	6
	Saturday	星期六	7
	Sunday		星期日	1

#求2016年4月13号的下一个星期六，是几月几号
	SQL> SELECT to_char(next_day(to_date('2016-4-13','yyyy-mm-dd'),7),'yyyy-mm-dd') FROM DUAL;
	TO_CHAR(NE
	----------
	2016-04-16
#求2016年3月19号（星期六）的下一个星期六，是几月几号
	SQL> SELECT to_char(next_day(to_date('2016-3-19','yyyy-mm-dd'),7),'yyyy-mm-dd') FROM DUAL
	TO_CHAR(NE
	----------
	2016-03-26

------------
#LAST_DAY		一个月的最后一天

#ROUND		四舍五入
	SQL> SELECT to_char(sysdate,'yyyy-mm-dd') FROM DUAL;
	TO_CHAR(SY
	----------
	2016-03-17
	SQL> SELECT to_char(round(sysdate,'MONTH'),'yyyy-mm-dd') FROM DUAL;			#round里面使用的是月
	TO_CHAR(RO
	----------
	2016-04-01			#时间变成了4月1号，因为系统时间是3月17号，过了3月15号了，所以就进为了4月1号

	SQL> SELECT to_char(round(sysdate,'YEAR'),'yyyy-mm-dd') FROM DUAL;			#round里面使用的是年
	TO_CHAR(RO
	----------
	2016-01-01			#时间变成了1月1号，因为系统时间是3月，没有过6月份，所以就舍为了1月1号

----------------
#TRUNC		截断
	SQL> SELECT to_char(trunc(sysdate,'MONTH'),'yyyy-mm-dd') FROM DUAL
	TO_CHAR(TR
	----------
	2016-03-01			#trunc里面使用的是月，不管是几号，都截取为当前月的1号
	SQL> SELECT to_char(trunc(sysdate,'YEAR'),'yyyy-mm-dd') FROM DUAL
	TO_CHAR(TR
	----------
	2016-01-01			#trunc里面使用的是年，不管是几月，都截取为当前年的1月1号










