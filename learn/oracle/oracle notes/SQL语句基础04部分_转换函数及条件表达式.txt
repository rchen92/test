转换函数+条件表达式	（隐示和显示转换）
-----------------------
首先来看什么叫显示转换，最常见的就是字符串转换为数字，日期转换为字符等等
	显示转换3口诀：
		1、字符转和日期之间转换用to_date
		2、字符串和数字之间转换用to_number
		3、日期和数字都转换成字符串用to_char（to_char工作中用的最多）
-------------------
#例如：显示1981-1-1以后入职的员工的编号，姓名
	SQL> SELECT empno,ename,hiredate
	  2  FROM emp
	  3  WHERE hiredate>to_date('1981-1-1','yyyy-mm-dd');		#将1981-1-1字符串转换为1-JAN-81日期，
		 EMPNO ENAME      HIREDATE
	---------- ---------- ---------
		  7499 ALLEN      20-FEB-81				#但是这种看不清楚是哪个年
		  7521 WARD       22-FEB-81
		  7566 JONES      02-APR-81
		  7654 MARTIN     28-SEP-81
		  7698 BLAKE      01-MAY-81
		  7782 CLARK      09-JUN-81
	SQL> SELECT empno,ename,to_char(hiredate,'yyyy-mm-dd')		#将日期转换为字符串。
	  2  FROM emp
	  3  WHERE hiredate>to_date('1981-1-1','yyyy-mm-dd')
		 EMPNO ENAME      TO_CHAR(HI
	---------- ---------- ----------
		  7499 ALLEN      1981-02-20		#这里1981-01-01这种在我们中国人看来是日期，但其实是字符串。oracle里面的日期格式为1-JAN-81
		  7521 WARD       1981-02-22
		  7566 JONES      1981-04-02
		  7654 MARTIN     1981-09-28
		  7698 BLAKE      1981-05-01
		  7782 CLARK      1981-06-09

	SQL> SELECT empno,ename,hiredate
	  2  FROM emp
	  3  WHERE hiredate>'01-JAN-81';		#因为oracle本来默认的就是01-JAN-81的格式
		 EMPNO ENAME      HIREDATE
	---------- ---------- ---------
		  7499 ALLEN      20-FEB-81
		  7521 WARD       22-FEB-81
		  7566 JONES      02-APR-81
		  7654 MARTIN     28-SEP-81
		  7698 BLAKE      01-MAY-81

	#日期	字符串	--->	发生了隐示转换

----------------------
#隐示转换（有可能转换失败）
	SQL> SELECT empno,ename,hiredate
	  2  FROM emp
	  3  WHERE hiredate>'1981-1-1';
	WHERE hiredate>'1981-1-1'
				   *
	ERROR at line 3:
	ORA-01861: literal does not match format string		#格式不匹配，默认按照DD-MON-RR转换

#建议使用显示转换

#日期--->字符
	SQL> SELECT to_char(sysdate,'YYYY') FROM DUAL;
	TO_C
	----
	2016	#这里看着是日期/数字，但其实是字符串
	SQL> SELECT to_char(sysdate,'year') FROM DUAL;
	TO_CHAR(SYSDATE,'YEAR')
	------------------------------------------
	twenty sixteen			#小写的
	SQL> SELECT to_char(sysdate,'YEAR') FROM DUAL;
	TO_CHAR(SYSDATE,'YEAR')
	------------------------------------------
	TWENTY SIXTEEN			#大写的
	SQL> SELECT to_char(sysdate,'YEAR-mm') FROM DUAL;
	TO_CHAR(SYSDATE,'YEAR-MM')
	---------------------------------------------
	TWENTY SIXTEEN-03

----------------
#时间 hh24:mi:ss
	  hh:mi:ss AM
	  hh:mi:ss PM
	SQL> SELECT to_char(sysdate,'yyyy-mm-dd hh24:mi:ss') FROM DUAL;
	TO_CHAR(SYSDATE,'YY
	-------------------
	2016-03-18 10:05:10
	SQL> SELECT to_char(sysdate,'yyyy-mm-dd hh:mi:ss AM') FROM DUAL;
	TO_CHAR(SYSDATE,'YYYY-
	----------------------
	2016-03-18 10:05:37 AM
	SQL> SELECT to_char(sysdate,'yyyy-mm-dd hh:mi:ss PM') FROM DUAL;
	TO_CHAR(SYSDATE,'YYYY-
	----------------------
	2016-03-18 10:06:06 AM

#在中国我们最好使用 日期--->字符	to_char(日期,'yyyy-mm-dd hh24:mi:ss')

------------------------------
#数字--->字符
#格式：
	9	占位符	有就显示，没有不显示
	0	占位符	有就显示，没有则显示0
	$	美元
	L	本地货币
	,	千位
	.	小数点

#既然和货币有关，我们找到工资
	SQL> SELECT ename,to_char(sal,'9999.00')
	  2  FROM emp;
	ENAME	   TO_CHAR(
	---------- --------
	Xiaohong    5000.00
	SMITH	     800.00
	JONES	    2975.00
	MARTIN	    1250.00
	JAMES	     950.00
	SQL> SELECT ename,to_char(sal,'999.99') newsal		#如果给的位数不够，那就出错了，工资没有了
	  2  FROM emp;
	ENAME	   NEWSAL
	---------- -------
	Xiaohong   #######
	SMITH	    800.00
	JONES	   #######
	MARTIN	   #######
	JAMES	    950.00
	SQL> SELECT ename,to_char(sal,'$9999.00')		#显示为美元
	  2  FROM emp;
	ENAME	   TO_CHAR(S
	---------- ---------
	Xiaohong    $5000.00
	SMITH	     $800.00
	ALLEN	    $1600.00
	MARTIN	    $1250.00
	JAMES	     $950.00
	SQL> SELECT ename,to_char(sal,'L9999.00')		#显示为本地货币，还是美元，因为oracle的本地是在美国
	  2  FROM emp;
	ENAME	   TO_CHAR(SAL,'L9999
	---------- ------------------
	Xiaohong	     $5000.00
	SMITH		      $800.00
	ALLEN		     $1600.00
	MARTIN		     $1250.00
	JAMES		      $950.00

#9和0都表示占位，如果在小数位则是一样的效果，都表示有几个小数。如果在整数，9表示有就显示，没有则不显示；0表示有就显示，没有则显示0

---------------
#扩展：假设我现在要显示文件的编号和文件的名字
	SQL> conn / as sysdba;
	Connected.
	SQL> desc v$datafile;
	 Name					   Null?    Type
	 ------------------------- -------- ----------------------------
	 FILE#								NUMBER
	 CREATION_CHANGE#				    NUMBER
	 CREATION_TIME					    DATE
	......
	 BLOCKS 							NUMBER
	 CREATE_BYTES					    NUMBER
	 BLOCK_SIZE							NUMBER
	 NAME								VARCHAR2(513)			#这里有513个字节
	 PLUGGED_IN							NUMBER
	......
	SQL> SELECT file#,name		#后面会显示513个字节，但是这里用不到显示这么多
	  2  FROM v$datafile;
		 FILE#
	----------
	NAME
	--------------------------------------------------------------------------------
		 1
	+DATA/orcl/datafile/system.256.906413617

		 2
	+DATA/orcl/datafile/sysaux.257.906413619

		 3
	+DATA/orcl/datafile/undotbs1.258.906413621

		 4
	+DATA/orcl/datafile/users.259.906413623

		 5
	+DATA/orcl/datafile/example.265.906414135

	SQL> col name for a50;
	SQL> /
		 FILE# NAME
	---------- --------------------------------------------------
		 1 +DATA/orcl/datafile/system.256.906413617
		 2 +DATA/orcl/datafile/sysaux.257.906413619
		 3 +DATA/orcl/datafile/undotbs1.258.906413621
		 4 +DATA/orcl/datafile/users.259.906413623
		 5 +DATA/orcl/datafile/example.265.906414135
	SQL> col name for a45;
	SQL> /
		 FILE# NAME
	---------- ---------------------------------------------
		 1 +DATA/orcl/datafile/system.256.906413617
		 2 +DATA/orcl/datafile/sysaux.257.906413619
		 3 +DATA/orcl/datafile/undotbs1.258.906413621
		 4 +DATA/orcl/datafile/users.259.906413623
		 5 +DATA/orcl/datafile/example.265.906414135
	SQL> col name for a40;		#这种也不好看
	SQL> /
		 FILE# NAME
	---------- ----------------------------------------
		 1 +DATA/orcl/datafile/system.256.906413617
		 2 +DATA/orcl/datafile/sysaux.257.906413619
		 3 +DATA/orcl/datafile/undotbs1.258.9064136
		   21

		 4 +DATA/orcl/datafile/users.259.906413623
		 5 +DATA/orcl/datafile/example.265.90641413
		   5
	SQL> col name for a50;

----------------------
#所以以后看到哪一行短了，哪一行长了，可以使用col[umn]来设置
#col[umn] 字段名 for[mat] 格式
#col 列 for a数值

#但是如果规定文件编号显示3位，就要注意了
	SQL> col file# for a3;		#这种就显示不出来了
	SQL> /
		 FILE# NAME
	---------- --------------------------------------------------
	########## +DATA/orcl/datafile/system.256.906413617
	########## +DATA/orcl/datafile/sysaux.257.906413619
	########## +DATA/orcl/datafile/undotbs1.258.906413621
	########## +DATA/orcl/datafile/users.259.906413623
	########## +DATA/orcl/datafile/example.265.906414135
#数字--->格式命令	9 0 , . $ L
#所以应该这样写
	SQL> col file# for 000;
	SQL> /
	FILE# NAME
	----- -------------------------------------------------------
	  001 +DATA/orcl/datafile/system.256.906413617
	  002 +DATA/orcl/datafile/sysaux.257.906413619
	  003 +DATA/orcl/datafile/undotbs1.258.906413621
	  004 +DATA/orcl/datafile/users.259.906413623
	  005 +DATA/orcl/datafile/example.265.906414135

#column		format 在工作中使用非常多
#to_number(char[,'format_model'])	字符--->数字
#to_date(char[,'format_model'])		字符--->日期
---------------------------------------------
#例如：
	SQL> conn scott/oracle;
	Connected.
	SQL> SELECT ename,sal
	  2  FROM emp
	  3  WHERE empno=to_number('7788','9999')
	ENAME		  SAL
	---------- ----------
	SCOTT		 3000
	SQL> SELECT ename,sal
	  2  FROM emp
	  3* WHERE empno=to_number('99','9999')
	ENAME		  SAL
	---------- ----------
	Xiaohong	 5000
	SQL> SELECT ename,sal
	  2  FROM emp
	  3  WHERE empno=to_number('99','fx9999')			#加入 fx 的意思就是让你输入的时候必须是这种格式，这里是必须四位数
	WHERE empno=to_number('99','fx9999')
							   *
	ERROR at line 3:
	ORA-01481: invalid number format model
#这个地方有一个bug(版本的问题)，可以输入7788试一下
	SQL> SELECT ename,sal
	  2  FROM emp
	  3  WHERE empno=to_number('7788','fx9999')
	WHERE empno=to_number('7788','fx9999')
								 *
	ERROR at line 3:
	ORA-01481: invalid number format model
#to_date的写法可以成功
	SQL> SELECT to_date('1981-1-1','yyyy-mm-dd') FROM DUAL;
	TO_DATE('
	---------
	01-JAN-81
	SQL> SELECT to_date('1981-1-1','fxyyyy-mm-dd') FROM DUAL;
	SELECT to_date('1981-1-1','fxyyyy-mm-dd') FROM DUAL
				   *
	ERROR at line 1:
	ORA-01862: the numeric value does not match the length of the format item
	SQL> SELECT to_date('1981-01-01','fxyyyy-mm-dd') FROM DUAL;		#格式必须写全
	TO_DATE('
	---------
	01-JAN-81

-------------------------
#通用函数
#NVL，NVL2，NULLIF，COALESCE
------------------------
#nul(字段/列,值/替换)	这一列有就原意显示，没有就替换为后面的值（这个值和前面的字段是同一数据类型）
	SQL> SELECT ename,sal,comm,nvl(comm,0)+sal
	  2  FROM emp;
	ENAME			  SAL	    COMM NVL(COMM,0)+SAL
	---------- ---------- ---------- ---------------
	Xiaohong		 5000						5000
	SMITH			  800						 800
	ALLEN			 1600	     300			1900
	WARD			 1250	     500			1750
	JONES			 2975						2975
	MARTIN			 1250	    1400			2650
	BLAKE			 2850						2850
	CLARK			 2450						2450
	SCOTT			 3000						3000
	KING			 5000						5000
	TURNER			 1500	       0			1500
------------------------------
#nvl2(expr1,expr2,expr3)	判断expr1是否为空，为空则显示expr3，不为空则显示expr2
------------------------
#例如：求员工的姓名，奖金+工资
	SQL> SELECT ename,nvl2(comm,comm+sal,sal) FROM emp;
	ENAME	   NVL2(COMM,COMM+SAL,SAL)					#工作的时候不能这样显示
	---------- -----------------------
	Xiaohong		      5000
	SMITH			       800
	ALLEN			      1900
	WARD			      1750
	JONES			      2975
	SQL> ed
	  1  SELECT ename,nvl2(comm,comm+sal,sal) as newsal	
	  2* FROM emp
	SQL> /
	ENAME	       NEWSAL
	---------- ----------
	Xiaohong	 5000
	SMITH		  800
	ALLEN		 1900
	WARD		 1750
	JONES		 2975
----------------------------------
#nullif(expr1,expr2)	判断expr1和expr2是否相等，相等就为空，不相等显示expr1的值
	SQL> SELECT nullif(ename,'SCOTT')		#判断ename里面有没有和SCOTT相等的，没有就显示原来的ename，相等的就为空
	  2  FROM emp;

	NULLIF(ENA
	----------
	Xiaohong
	SMITH
	ALLEN
	WARD
	JONES
	MARTIN
	BLAKE
	CLARK
					#这里有SCOTT这个用户，但是显示为空
	KING
	TURNER
	#可以用这种方法排除危险字段
-----------------------------------
#coalesce(expr1,expr2,...,exprn)	从左向右依次判断表达式的值。如果不为空，则显示表达式的值，并退出。否则继续向右搜索。
	#expr表达式必须是字符串
------------------------------
#例如：求哪些人有奖金，有就显示姓名，奖金。如果没有奖金，再看有没有领导，有领导就显示领导编号；如果没有，最后显示wu，这个人没有奖金也没有领导
	SQL> SELECT ename,coalesce(to_char(comm),to_char(mgr),'wu')
	  2  FROM emp;
	ENAME	   COALESCE(TO_CHAR(COMM),TO_CHAR(MGR),'WU'
	---------- ----------------------------------------
	Xiaohong   wu		#没有奖金，没有领导
	SMITH	   7902		#没有奖金，有领导，显示领导编号
	ALLEN	   300		#有奖金，显示奖金
	WARD	   500
	JONES	   7839
	MARTIN	   1400
	BLAKE	   7839
	CLARK	   7839
	SCOTT	   7566
	KING	   wu
	TURNER	   0


---------------------------------
条件表达式：case，decode
-----------------
case
官方案例：
	case expr(列名) when comparison_expr1(行具体内容) then return_expr1(行 修改)
		[when comparison_expr2 then return_expr2 ...
		 when comparison_exprn then return_exprn
		 else else_expr]
	end

	SQL> SELECT distinct job from emp;		#列出不同的职位（distinct消除重复的行）
	JOB
	---------

	CLERK			#职员
	SALESMAN		#推销员
	PRESIDENT		#董事长
	MANAGER			#经理
	ANALYST			#分析师
		#现在加薪
	CLERK			+1000
	SALESMAN		+80
	PRESIDENT		
	MANAGER			
	ANALYST			+500
		#然后显示姓名，工资，岗位，根据岗位加薪，部门号
	SQL> SELECT ename,sal,job,deptno
	  2  FROM emp;
	ENAME		  SAL JOB	    DEPTNO
	---------- ---------- --------- ----------
	Xiaohong	 5000				10
	SMITH		  800 CLERK			20
	ALLEN		 1600 SALESMAN		30
	WARD		 1250 SALESMAN		30
	JONES		 2975 MANAGER		20

	SQL> ed
	SELECT ename,sal,job,
	case job WHEN 'CLERK' THEN sal+1000			#解释：CLERK，SALESMAN,ANALYST如果都在job里面就分别加1000,80,500，剩下的sal是多少就是
			WHEN 'SALESMAN' THEN sal+80			 多少，然后取了2个别名。end代表case开始一直到end结束时一个字段
			WHEN 'ANALYST' THEN sal+500
			ELSE sal end newsal,
	deptno
	FROM emp
	SQL> /

	ENAME			  SAL JOB			NEWSAL     DEPTNO
	---------- ---------- --------- ---------- ----------
	Xiaohong		 5000				  5000		   10
	SMITH			  800 CLERK			  1800		   20
	ALLEN			 1600 SALESMAN	      1680		   30
	WARD			 1250 SALESMAN	      1330		   30
	JONES			 2975 MANAGER	      2975		   20
	MARTIN			 1250 SALESMAN	      1330		   30
	BLAKE			 2850 MANAGER	      2850		   30
	CLARK			 2450 MANAGER	      2450		   10
	SCOTT			 3000 ANALYST	      3500		   20
	KING			 5000 PRESIDENT       5000		   10
	TURNER			 1500 SALESMAN	      1580		   30

-----------------------------------
decode
#使用decode替换case语句		#工作中decode语句要用的多得多
case expr(列名) when comparison_expr1(行具体内容) then return_expr1(行 修改)
	[when comparison_expr2 then return_expr2 ...
	when comparison_exprn then return_exprn
	else else_expr]
end

#按照上面的case语句把它改成decode语句
#when then else --->替换为	,(逗号)
#end不要
#用括号括起来
decode ( expr(列名),comparison_expr1(行具体内容),return_expr1(行 修改)		#如果行具体内容1符合列名，则将这一行的内容改为后面的值1
	,comparison_expr2,return_expr2 ...			#如果行具体内容2符合列名，则将这一行的内容改为后面的值2
	,comparison_exprn,return_exprn				......
	,else_expr )						#否则将显示什么
	
	SQL> ed
	SELECT ename,sal,job,
	decode ( job ,'CLERK',sal+1000
			,'SALESMAN',sal+80
			,'ANALYST',sal+500
			,sal ) newsal,
	deptno
	FROM emp
	/
	SQL> /
	ENAME		  SAL JOB			NEWSAL     DEPTNO
	---------- ---------- --------- ---------- ----------
	Xiaohong	 5000				  5000	   10
	SMITH		  800 CLERK			  1800	   20
	ALLEN		 1600 SALESMAN	      1680	   30
	WARD		 1250 SALESMAN	      1330	   30
	JONES		 2975 MANAGER	      2975	   20
	MARTIN		 1250 SALESMAN	      1330	   30
	BLAKE		 2850 MANAGER	      2850	   30
	CLARK		 2450 MANAGER	      2450	   10
	SCOTT		 3000 ANALYST	      3500	   20
	KING		 5000 PRESIDENT       5000	   10
	TURNER		 1500 SALESMAN	      1580	   30
	#结果是一样的，但是回过头来看一下语法，decode比case要精简的多



这次课后争取看懂这个脚本的第一部分
目标
检查表空间脚本
SELECT D.STATUS STATUS,
	D.TABLESPACE_NAME NAME,
	D.CONTENTSTYPE,
	D.EXTENT_MANAGEMENT EXTENTMANAGEMENT,
	TO_CHAR(NVL(A.BYTES/1024/1024,0),'99,999,990.900') TABLE_SIZE,
	TO_CHAR(NVL(A.BYTES-NVL(F.BYTES,0),0)/1024/1024,'99999999.999') || '/' ||
	TO_CHAR(NVL(A.BYTES/1024/1024,0),'99999999.999') USED,
	TO_CHAR(NVL((A.BYTES-NVL(F.BYTES,0))/A.BYTES*100,0),'990.00') RATE
FROM SYS.DBA_TABLESPACESD,
	(SELECT TABLESPACE_NAME,SUM(BYTES) BYTES 
		FROM DBA_DATA_FILES
		GROUP BY TABLESPACE_NAME) A,
	(SELECT TABLESPACE_NAME,SUM(BYTES) BYTES
		FROM DBA_FREE_SPACE
		GROUP BY TABLESPACE_NAME) F
WHERE D.TABLESPACE_NAME=A.TABLESPACE_NAME(+)
	AND D.TABLESPACE_NAME=F.TABLESPACE_NAME(+)
	AND NOT
		(D.EXTENT_MANAGEMENT LIKE 'LOCAL' AND D.CONTENTSLIKE 'TEMPORARY')















