关系型数据库  ---> 表 堆表 索引组织 分区表 簇表
堆表 基本表

---------------------------------------------
#怎么建立一个表
#先进sysdba
	[oracle@oracle-server ~]$ sqlplus / as sysdba
#表是属于谁的：用户的，那先创建一个用户
	SQL> CREATE USER tom IDENTIFIED BY oracle;
	User created.
	SQL> conn tom/oracle;		#没有权限
	ERROR:
	ORA-01045: user TOM lacks CREATE SESSION privilege; logon denied
	Warning: You are no longer connected to ORACLE.
	SQL> show user;
	USER is ""
	SQL> conn / as sysdba;
#授予用户登录数据库权限
	SQL> GRANT connect to tom;
	Grant succeeded.
	SQL> conn tom/oracle;
	SQL> CREATE TABLE xs(id number) SEGMENT CREATION IMMEDIATE;		#没有创建的权限
	CREATE TABLE xs(id number) SEGMENT CREATION IMMEDIATE
	*
	ERROR at line 1:
	ORA-01031: insufficient privileges
	SQL> conn / as sysdba;
#授予用户创建表的权限
	SQL> GRANT CREATE TABLE TO tom;
	Grant succeeded.
	SQL> conn tom/oracle;	#知识储备：在11g里面空间分配是延迟分配，建立一个表立即分配表空间
	SQL> CREATE TABLE xs(id number) SEGMENT CREATION IMMEDIATE;
	CREATE TABLE xs(id number) SEGMENT CREATION IMMEDIATE
	*
	ERROR at line 1:
	ORA-01950: no privileges on tablespace 'USERS'		#没有权限使用USERS表空间
	SQL> conn / as sysdba
	SQL> ALTER USER tom quota 20M on users;			#从users里面拿20M的表空间给tom
	User altered.
	SQL> CREATE TABLE xs(id number) SEGMENT CREATION IMMEDIATE;		#现在才创建成功
	Table created.
	SQL> DESC xs;
	Name		   Null?    Type
	-------------- -------- -------------
	ID						NUMBER
	SQL> SELECT * FROM tab;
	TNAME			 TABTYPE	CLUSTERID
	---------------- ------- ----------
	XS			     TABLE
#解决语法问题？
	掌握：数据类型	约束
	总结：建立表	至少掌握
	1 权限 create table
	2 空间：有表空间的使用空间的配额
	3 语法：数据类型 约束	（这个很重要）
-----------------------------
#扩展知识：一个用户去访问另外一个用户的表或者其他对象，必须把对方拥有者作为对象的前缀，且有权限
	如：scott.emp
		SELECT * FROM scott.emp;
		SELECT * FROM emp;	没有前缀，表示当前用户
	总结：统一规范，所有对象前面加拥有者作为前缀


---------------------------
#Data Types（必须掌握）
	字符
	数字
	日期

-------------------------
#字符
	char(n)		
	varchar2(n)
	nchar(n)
	nvarchar2(n)

	SQL> CREATE TABLE y_char (name char(10));
	SQL> CREATE TABLE y_varchar2 (name varchar2(10));
	SQL> CREATE TABLE y_char (name char(10)) ;
	SQL> DESC y_char;
	 Name					   Null?    Type
	 ----------------------------------------- -------- ----------------------------
	 NAME						    CHAR(10)
	SQL> DESC y_varchar2;
	 Name					   Null?    Type
	 ----------------------------------------- -------- ----------------------------
	 NAME						    VARCHAR2(10)
	SQL> INSERT INTO y_char values('a');
	SQL> INSERT INTO y_char values('aaaaaaaaaaaaaaaaaaaaaaa');
	INSERT INTO y_char values('aaaaaaaaaaaaaaaaaaaaaaa')
							  *
	ERROR at line 1:
	ORA-12899: value too large for column "TOM"."Y_CHAR"."NAME" (actual: 23, maximum: 10)	#最大长度为10个字符

	SQL> INSERT INTO y_varchar2 values('a');
	SQL> INSERT INTO y_varchar2 values('aaaaaaaaaaaaaaaaaaaaaaaa');
	INSERT INTO y_varchar2 values('aaaaaaaaaaaaaaaaaaaaaaaa')
								  *
	ERROR at line 1:
	ORA-12899: value too large for column "TOM"."Y_VARCHAR2"."NAME" (actual: 24, maximum: 10)	#这个最大长度也为10个

	SQL> SELECT name,dump(name,1016) FROM y_char;
	NAME
	----------
	DUMP(NAME,1016)
	----------------------------------------------------------------------------------------------------
	a
	Typ=96 Len=10 CharacterSet=ZHS16GBK: 61,20,20,20,20,20,20,20,20,20
										#a就是61	
											1   2  3  4  5  6  7  8  9	#用9个20补齐了剩下的9个位置，空格为20
		Type=96 ---> 代表的是cahr类型
		Len=10	---> 代表不能超过10个字节
		CharaterSet	 存储的字符集类型

	SQL> SELECT name,dump(name,1016) FROM y_varchar2;
	NAME
	----------
	DUMP(NAME,1016)
	----------------------------------------------------------------------------------------------------
	a
	Typ=1 Len=1 CharacterSet=ZHS16GBK: 61
											#后面没有用空格 20  补齐
	#所以char和varchar2里面都输入a，但是数据不可以比较

	[oracle@oracle-server ~]$ xhost +
	[oracle@oracle-server ~]$ lbuilder 
	选择字符集	---> ZHS16GBK ---> 输入61  ---> 字符是a
					 ZHS16GBK ---> 输入20  ---> 字符是空格
---------------------------
#char(n)	定长字符型
#varchar2(n)	n表示允许最大允许数据的字节数，不能超过n，可以比n小，不用空格填充，存什么是什么

	SQL> CREATE TABLE t1 (id1 number, c1 char(10),c2 varchar2(10));
	SQL> BEGIN
	  2  INSERT INTO t1 values(1,'a','a');
	  3  INSERT INTO t1 values(2,'a','b');
	  4  INSERT INTO t1 values(3,'c','c');
	  5  end;
	  6  /
	PL/SQL procedure successfully completed.
	SQL> SELECT * FROM t1;
		   ID1 C1	      C2
	---------- ---------- ----------
			 1 a	      a
			 2 a	      b
			 3 c	      c
	SQL> DESC t1;
	 Name			   Null?	Type
	 ----------------- -------- ------------------
	 ID1						NUMBER
	 C1							CHAR(10)
	 C2							VARCHAR2(10)		#c1是char，c2是varchar2
	SQL> SELECT * FROM t1
	  2  WHERE c1=c2;
	no rows selected		#是为空的，因为字符类型不一样
	SQL> ed
	Wrote file afiedt.buf
	  1  SELECT * FROM t1
	  2* WHERE trim( c1)=c2		#去空格就可以了
	SQL> /
		   ID1 C1	      C2
	---------- ---------- ----------
			 1 a	      a
			 3 c	      c
---------------------------------
#知识贮备：一个数据库有2个字符集
	一个叫数据库字符集（一般用）
	一个叫国家字符集
	SQL> conn / as sysdba
	SQL> DESC database_properties;
	 Name					   Null?    Type
	 ------------------------- -------- ----------------------------
	 PROPERTY_NAME			   NOT NULL VARCHAR2(30)
	 PROPERTY_VALUE 				    VARCHAR2(4000)
	 DESCRIPTION					    VARCHAR2(4000)
	SQL> SELECT PROPERTY_NAME,PROPERTY_VALUE FROM database_properties;

	PROPERTY_NAME		       PROPERTY_VALUE
	------------------------------ -----------------------------------
	DICT.BASE		       2
	DEFAULT_TEMP_TABLESPACE        TEMP
	DEFAULT_PERMANENT_TABLESPACE   USERS
	DEFAULT_EDITION 	       ORA$BASE
	Flashback Timestamp TimeZone   GMT
	TDE_MASTER_KEY_ID
	DST_UPGRADE_STATE	       NONE
	DST_PRIMARY_TT_VERSION	       11
	DST_SECONDARY_TT_VERSION       0
	DEFAULT_TBS_TYPE	       SMALLFILE
	NLS_LANGUAGE		       AMERICAN

	PROPERTY_NAME		       PROPERTY_VALUE
	------------------------------ -----------------------------------
	NLS_TERRITORY		       AMERICA
	NLS_CURRENCY		       $
	NLS_ISO_CURRENCY	       AMERICA
	NLS_NUMERIC_CHARACTERS	       .,
	NLS_CHARACTERSET	       ZHS16GBK			#数据库字符集
	NLS_CALENDAR		       GREGORIAN
	NLS_DATE_FORMAT 	       DD-MON-RR
	NLS_DATE_LANGUAGE	       AMERICAN
	NLS_SORT		       BINARY
	NLS_TIME_FORMAT 	       HH.MI.SSXFF AM
	NLS_TIMESTAMP_FORMAT	       DD-MON-RR HH.MI.SSXFF AM

	PROPERTY_NAME		       PROPERTY_VALUE
	------------------------------ -----------------------------------
	NLS_TIME_TZ_FORMAT	       HH.MI.SSXFF AM TZR
	NLS_TIMESTAMP_TZ_FORMAT        DD-MON-RR HH.MI.SSXFF AM TZR
	NLS_DUAL_CURRENCY	       $
	NLS_COMP		       BINARY
	NLS_LENGTH_SEMANTICS	       BYTE
	NLS_NCHAR_CONV_EXCP	       FALSE
	NLS_NCHAR_CHARACTERSET	       AL16UTF16
	NLS_RDBMS_VERSION	       11.2.0.1.0
	GLOBAL_DB_NAME		       ORCL.EXAMPLE.COM
	EXPORT_VIEWS_VERSION	       8
	WORKLOAD_CAPTURE_MODE

	PROPERTY_NAME		       PROPERTY_VALUE
	------------------------------ -----------------------------------
	WORKLOAD_REPLAY_MODE
	NO_USERID_VERIFIER_SALT        8BF56230FC49D6ECFE53EB96A5922DD5
	DBTIMEZONE		       00:00
	36 rows selected.
-------------------------------
#字符集如何存储
	ASCII	1个字符占1个字节
	AL32UTF8	1个汉字占3个字节，1个字母占1个字节
	ZHS16GBK	1个汉字占2个字节，1个字母占1个字节
	AL16UTF16	汉字和字母都占2个字节

---------------------------
#数字
	number(p,s)
	s表示精度，p从精度位开始向左数的最多有效位数
		s精度表示
			1	2	3	4.	5	6	7
		   -3  -2  -1	0	1	2	3
		   最大值990
			number(2,0)	最大值99
			NUMBER(7,2) 最大值99999.99
			NUMBER(2,-1) 从十位开始，向左有效位数为2位，最大值显示为990
------------------------------
	SQL> conn tom/oracle
	SQL> INSERT INTO t_number values(990);
	SQL> ed
	Wrote file afiedt.buf
	  1* INSERT INTO t_number values(992)
	SQL> /
	SQL> ed
	Wrote file afiedt.buf
	  1* INSERT INTO t_number values(994)
	SQL> /
	SQL> ed
	Wrote file afiedt.buf
	  1* INSERT INTO t_number values(995)
	SQL> /
	INSERT INTO t_number values(995)
								*
	ERROR at line 1:
	ORA-01438: value larger than specified precision allowed for this column
	#最大可以插入990,991,992,993,994，但是不能插入995，而且显示的是990。因为精度是到十位，个位是四舍五入，所以不能写5
	SQL> SELECT * FROM t_number;
			C1
	----------
		   990
		   990
		   990
	CREATE TABLE shiwan (sal number(8,2))

------------------------------
#日期
#不同时区的时间计算
	同减异加，东加西减
	“同”指同在东时区或同在西时区，则两时区相减（例如东八区和东五区都在东时区，则8-5=3）。“异”则相反
	遵循一张零时区居中的世界地图，所求时区在已知时区东边则同减西加的结果加上已知时区的时间。否则为减
	凡向西走，每走过一个时区，就要把表向前拨1小时(2点拨到1点)；凡向东走，每过一个时区，就要把表向后拨1小时(1点拨到2点)

	要计算的区时=已知区时-(已知区时的时区-要计算区时的时区)		（注：东时区为正，西时区为负）
-------------------------
#例子：已知北京（东八区）时间为5月1日12:00，求东京（东九区）的区时
			12:00（已知区时）-(8（已知区时的时区）-9（要计算区时的时区）)=13:00（要计算的区时）
---------------------------
#例：已知北京时间为5月1日12:00，求伦敦（中时区）的区时
					12:00-(8-0)=4:00
------------------------
#例：已知北京时间为5月1日12:00，求纽约（西五区）的区时
					12:00-(8-(-5))=-1:00+24:00 -1天=23:00	即纽约时间为4月30日的23:00
	#注：当算出的区时为负数时，应加上24:00，日期减一天，及5月1日变为4月30日
--------------------------
#例：已知纽约时间为5月1日12:00，求东京的区时
					12:00-(-5-9)=26:00-24:00 +1天=2:00	即东京时间为5月2日的凌晨2:00
	#注：当算出的区时大于或等于24:00时，应减去24:00，日期加一天，即从5月1日变为5月2日
-----------------------
#练习：巴西下午4点（已知巴西时区=西三区），那么北京时间是几点？
		16:00-(-3-8)=27:00-24:00 +1天=3:00	即北京时间为第二天的凌晨3点

















