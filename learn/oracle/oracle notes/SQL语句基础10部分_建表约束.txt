#约束 constraint
	约束：约束是实现高级完整性的一种方法
------------------------------
#掌握
	NOT NULL	非空
	UNIQUE		唯一键
	PRIMARY KEY		主键
	FOREIGN KEY		外键
	CHECK		检查
#语法：
	CREATE TABLE 表名 (字段名 字段类型 CONSTRAINT 约束名字 约束类型);
	ALTER TABLE 表名 ADD CONSTRAINT 约束名字 约束类型;
	ALTER TABLE 表名 DROP CONSTRAINT 约束名字;
--------------------------------
#建议为约束一个名字，否则默认是 sys_cN
	SQL> conn scott/oracle
	SQL> CREATE TABLE xs (id number(10) not null);
	SQL> DESC user_constraints;					#这个是约束图，记录了全部的约束信息
	 Name						       Null?	Type
	 --------------------------------- -------- ------------------------------------
	 OWNER										VARCHAR2(30)
	 CONSTRAINT_NAME #约束的名字	   NOT NULL VARCHAR2(30)
	 CONSTRAINT_TYPE #约束的类型				VARCHAR2(1)
	 TABLE_NAME		 #表的名字	       NOT NULL VARCHAR2(30)
	 SEARCH_CONDITION							LONG
	 R_OWNER									VARCHAR2(30)
	 R_CONSTRAINT_NAME							VARCHAR2(30)
	 DELETE_RULE								VARCHAR2(9)
	 STATUS 									VARCHAR2(8)
	 DEFERRABLE									VARCHAR2(14)
	 DEFERRED									VARCHAR2(9)
	 VALIDATED									VARCHAR2(13)
	 GENERATED									VARCHAR2(14)
	 BAD										VARCHAR2(3)
	 RELY										VARCHAR2(4)
	 LAST_CHANGE								DATE
	 INDEX_OWNER								VARCHAR2(30)
	 INDEX_NAME									VARCHAR2(30)
	 INVALID									VARCHAR2(7)
	 VIEW_RELATED								VARCHAR2(14)
	SQL> SELECT constraint_name,constraint_type,table_name FROM user_constraints WHERE table_name='XS'
	CONSTRAINT_NAME 	   C TABLE_NAME	
	---------------------- - ----------------
	SYS_C0011103		   C XS
		#不指定约束的名字，系统会自动取一个约束名
		#但是这个表约束的名字不好，因为这一看不知道是什么东西。如果我一个表里面有很多约束，而且都没有取名字，那当我想删除其中一个约束的时候会不知道删除哪一个，不敢删除的。
	SQL> DROP TABLE xs purge;
	SQL> CREATE TABLE xs (id number(10) constraint xs_id_notnull not null);		#删除之后重新创建一个新的，约束名叫xs_id_notnull
	SQL> DESC xs 
	 Name					Null?	 Type
	 ---------------------- -------- --------------
	 ID						NOT NULL NUMBER(10)
	SQL> SELECT constraint_name,constraint_type,table_name FROM user_constraints WHERE table_name='XS';
	CONSTRAINT_NAME 	    C TABLE_NAME
	----------------------- - -------------------
	XS_ID_NOTNULL		    C XS
		#现在约束名就是XS_ID_NOTNULL
------------------------------------
#删除约束
	ALTER TBALE 表名 DROP CONSTRIANT 约束名
-------------------------------
#注：约束在使用方法1创建表的时候给，使用方法2可以在创建完表后给。约束可以是列级别，还可以是表级别
	方法1：约束列级别方法：
		列级别
		字段名 数据类型 CONSTRAINT 约束名 约束类型 值或者范围
	方法2：约束表级别方法：
		表级别
		字段名 数据类型 ,......,CONSTRAINT 约束名 约束类型 值或者范围
			解释：表级别一般情况都是等你字段，也就是列全部写完后再写约束
-------------------------------
#1  NOT NULL CONSTRAINT
#作用：该约束所在的字段的值不能包含空
	SQL> conn scott/oracle
	SQL> DROP TABLE xs purge;
	SQL> CREATE TABLE xs (id number(10) not null);
	SQL> DESC xs 
	 Name				Null?	 Type
	 ------------------ -------- --------------
	 ID					NOT NULL NUMBER(10)
	SQL> INSERT INTO xs values(null);
	INSERT INTO xs values(null)
						  *
	ERROR at line 1:
	ORA-01400: cannot insert NULL into ("SCOTT"."XS"."ID")	#这里面不能用空
-------------------------------
#2  UNIQUE CONSTRAINT
#作用：唯一约束所在的字段的值不允许出现重复，还会在该字段上建立一个和约束同名的索引，在一个表唯一约束可以有多个。
	注：不少oracle学习笔记上把唯一约束和主键搞混了。其实 主键只能有一个，而唯一约束可以在一个表上有多个
	SQL> DROP TABLE xs purge;
	SQL> CREATE TABLE xs (id number(10) constraint xs_id_notnull not null,name char(10) constraint un_xs_name unique);
	SQL> DESC xs;
	 Name				Null?	 Type
	 ------------------ -------- -----------------
	 ID					NOT NULL NUMBER(10)
	 NAME								CHAR(10)
	SQL> INSERT INTO xs values(1,'xiaohong');
	SQL> /
	INSERT INTO xs values(1,'xiaohong')
	*
	ERROR at line 1:
	ORA-00001: unique constraint (SCOTT.UN_XS_NAME) violated		#不能再创建xiaohong了，因为这是唯一约束
	SQL> INSERT INTO xs values(2,null);
	1 row created.
	SQL> /			#这种可以一直创建了。插入空值？（这个地方，唯一约束有这个问题，可以插入空值，体现不出来唯一）
	1 row created.
	SQL> /
	1 row created.
	SQL> SELECT * FROM xs;
			ID NAME
	---------- ----------
			 1 xiaohong
			 2
			 2
			 2
	SQL> SELECT CONSTRAINT_NAME,CONSTRAINT_TYPE,TABLE_NAME 
	  2  FROM user_constraints
	  3  WHERE table_name='XS';
	CONSTRAINT_NAME 	       C TABLE_NAME
	-------------------------- - ------------------
	XS_ID_NOTNULL		       C XS
	UN_XS_NAME				   U XS
----------------------------------
#3 PRIMARY KEY CONSTRAINT	主键简写成pk
#作用：保证主键所在的字段的值是唯一的，而且没有空并且主键所在列上会建立和主键同名的索引，并且一个表有且仅有1个主键
#键(key)：能唯一标示一行记录的字段或者字段的组合。键可以有多个
#主键：在键中挑一个做为主键。主键是唯一的
	（如：火车站一个人身上有多个身份标识，如身份证、驾照、社保卡等，但是我们一般认为身份证就是这个人的主键，其他的都是键）
	SQL> ALTER TABLE xs ADD CONSTRAINT pk_xs_id primary key (id);	 #把主键约束加进去，主键既具有非空特性，又具有唯一特性。是两者结合
	ALTER TABLE xs ADD CONSTRAINT pk_xs_id primary key (id)
								  *
	ERROR at line 1:
	ORA-02437: cannot validate (SCOTT.PK_XS_ID) - primary key violated
	SQL> DROP TABLE xs purge;			#先删了，重新建吧
	SQL> CREATE TABLE xs (id number(10) CONSTRAINT pk_xs_id primary key)	#主键约束
	Table created.
	SQL> DESC xs;
	 Name				   Null?    Type
	 --------------------- -------- ------------
	 ID					   NOT NULL NUMBER(10)		#现在只是显示出了不空，那唯一性怎么看
	SQL> INSERT INTO xs values(1);			#插入个数据
	SQL> /
	INSERT INTO xs values(1)
	*
	ERROR at line 1:
	ORA-00001: unique constraint (SCOTT.PK_XS_ID) violated		#唯一性约束
	SQL> INSERT INTO xs values(null);
	INSERT INTO xs values(null)
						  *
	ERROR at line 1:
	ORA-01400: cannot insert NULL into ("SCOTT"."XS"."ID")		#不空性约束
	#现在主键就生成了
---------------------------------
#4 FOREIGN KEY CONSTRAINT	简写为fk  （比较麻烦）
#作用：保证参照完整性		#注：一句话总结外键：父亲和子女的关系
	一个表a的一个字段a，必须参考另外一个表b的一个字段b
		一个表a称为子表 外键所在的表，也就是表a的字段a上建立外键
		一个表b称为父表 字段b被参照，所以字段b必须唯一或者主键列
-----------------------
#以scott的emp表和dept表为例
	一个表emp的资格字段deptno，必须参照另外一个表dept的一个字段deptno
	这样做的好处：绝对不会出现“没有部门的员工”，因为绝对是先有部门才有员工的
----------------------------
#e表的deptno参照d表的deptno，则e表的deptno为子，d表的deptno为父
	SQL> DESC e;
	 Name				   Null?    Type
	 --------------------- -------- ----------------------------
	 EMPNO						    NUMBER(4)
	 ENAME						    VARCHAR2(10)
	 JOB						    VARCHAR2(9)
	 MGR						    NUMBER(4)
	 HIREDATE					    DATE
	 SAL						    NUMBER(7,2)
	 COMM						    NUMBER(7,2)
	 DEPTNO 					    NUMBER(2)
	SQL> DESC d;
	 Name					   Null?	Type
	 ------------------------- -------- ------------------------------------
	 DEPTNO 							NUMBER(2)
	 DNAME								VARCHAR2(14)
	 LOC								VARCHAR2(13)
	#添加约束（这个地方也就是之前说的表已经建立好了我们再添加约束）。现在首先要让d表的deptno成为主键
	SQL> ALTER TABLE d ADD CONSTRAINT pk_d_deptno primary key (deptno);
	SQL> DESC d;
	 Name					   Null?	Type
	 ------------------------- -------- ------------------------------------
	 DEPTNO 				   NOT NULL NUMBER(2)
	 DNAME								VARCHAR2(14)
	 LOC								VARCHAR2(13)
	#添加外键。现在让e表deptno去参照d表的deptno
	SQL> ALTER TABLE e ADD CONSTRAINT fk_e_deptno_d_deptno foreign key (deptno) references d (deptno)
	Table altered.
	SQL> INSERT INTO e(deptno) values(50);
	INSERT INTO e(deptno) values(50)
	*
	ERROR at line 1:
	ORA-02291: integrity constraint (SCOTT.FK_E_DEPTNO_D_DEPTNO) violated - parent key not found	
	#虽然创建的是e表里面的，但是部门编号归d表管。也就是e的deptno是子表，必须参照d的deptno，而d表的deptno里面没有50部门，所以创建失败
	SQL> DELETE FROM d WHERE deptno=20;
	DELETE FROM d WHERE deptno=20
	*
	ERROR at line 1:
	ORA-02292: integrity constraint (SCOTT.FK_E_DEPTNO_D_DEPTNO) violated - child record found		
	#在删除的时候发现e表的deptno为子表还存在，还依赖着d表的deptno父表，所以不能删除
--------------------------------------
#如果有外键约束
	那么你对子表做update insert的时候都要检查是否满足参照完整性
	那么你对父表做delete update的时候都要检查是否满足参照完整性
#外键里面：子表中添加看父表，父表中删除看子表
--------------------------------------
#删除（delete）
#比如对父表做delete，只有所有参照你的字段的值都删除了，才可以删除父表
#一定要删除怎么办？
	外键带有2个属性：
	第一：ON DELETE CASCADE:Deletes the dependent rows in the child table when a row in the parent table is deleted.
		级联删除
	第二：ON DELETE SET NULL:Converts depentdent foreign key values to null.
		父表删除，子表都设置为空
	SQL> DESC user_constraints;
	 Name						       Null?	Type
	 ----------------------------------------------------- -------- ------------------------------------
	 OWNER								VARCHAR2(30)
	 CONSTRAINT_NAME				       NOT NULL VARCHAR2(30)
	 CONSTRAINT_TYPE						VARCHAR2(1)
	 TABLE_NAME					       NOT NULL VARCHAR2(30)
	 SEARCH_CONDITION						LONG
	 R_OWNER							VARCHAR2(30)
	 R_CONSTRAINT_NAME						VARCHAR2(30)
	 DELETE_RULE							VARCHAR2(9)
	 STATUS 							VARCHAR2(8)
	 DEFERRABLE							VARCHAR2(14)
	 DEFERRED							VARCHAR2(9)
	 VALIDATED							VARCHAR2(13)
	 GENERATED							VARCHAR2(14)
	 BAD								VARCHAR2(3)
	 RELY								VARCHAR2(4)
	 LAST_CHANGE							DATE
	 INDEX_OWNER							VARCHAR2(30)
	 INDEX_NAME							VARCHAR2(30)
	 INVALID							VARCHAR2(7)
	 VIEW_RELATED							VARCHAR2(14)
	SQL> SELECT  CONSTRAINT_NAME,CONSTRAINT_TYPE,TABLE_NAME,DELETE_RULE
	  2  FROM user_constraints
	  3  WHERE table_name='E';
	CONSTRAINT_NAME 	       C TABLE_NAME		DELETE_RU
	-------------------------- - -------------- ---------
	FK_E_DEPTNO_D_DEPTNO	   R E				NO ACTION
							#R代表references	#删除规则为NO ACTION
							#如果有参照性，则不能删除
	#如果一定要删除
	方法1：先修改属性为 ON DELETE CASCADE		#在生产环境中一定要慎用
		SQL> ALTER TABLE e DROP CONSTRAINT FK_E_DEPTNO_D_DEPTNO;
		SQL> ALTER TABLE e ADD CONSTRAINT FK_E_DEPTNO_D_DEPTNO FOREIGN KEY (deptno) REFERENCES d(deptno) ON DELETE CASCADE;
		SQL> SELECT  CONSTRAINT_NAME,CONSTRAINT_TYPE,TABLE_NAME,DELETE_RULE
		  2  FROM user_constraints
		  3  WHERE table_name='E';
		CONSTRAINT_NAME 	       C TABLE_NAME		DELETE_RU
		-------------------------- - -------------- ---------
		FK_E_DEPTNO_D_DEPTNO	   R E				CASCADE
		SQL> SELECT ename,deptno FROM e;	#现在e表有10,20,30号部门
		ENAME	       DEPTNO
		---------- ----------
		Xiaohong	   10
		SMITH		   20
		ALLEN		   30
		......
		FORD		   20
		MILLER		   10
		xiao
		16 rows selected.
		SQL> DELETE FROM d WHERE deptno=10;		#现在就会级联删除10号部门
		SQL> SELECT ename,deptno FROM e;	#现在e表的10号部门整个都没有了。这种方式太野蛮了，不好。一个不小心误删了就完了。
		ENAME	       DEPTNO
		---------- ----------
		SMITH		   20
		ALLEN		   30
		WARD		   30
		JONES		   20
		MARTIN		   30
		BLAKE		   30
		SCOTT		   20
		TURNER		   30
		ADAMS		   20
		JAMES		   30
		FORD		   20
		xiao
		12 rows selected.
	方法2：修改属性为ON DELETE SET NULL
		先删除，再添加
		SQL> ALTER TABLE e DROP CONSTRAINT FK_E_DEPTNO_D_DEPTNO;
		SQL> ALTER TABLE e ADD CONSTRAINT FK_E_DEPTNO_D_DEPTNO FOREIGN KEY (deptno) REFERENCES d(deptno) ON DELETE SET NULL;
		SQL> SELECT  CONSTRAINT_NAME,CONSTRAINT_TYPE,TABLE_NAME,DELETE_RULE
		  2  FROM user_constraints
		  3  WHERE table_name='E';
		CONSTRAINT_NAME 	       C TABLE_NAME		DELETE_RU
		-------------------------- - -------------- ---------
		FK_E_DEPTNO_D_DEPTNO	   R E				SET NULL
		SQL> SELECT ename,deptno FROM e;
		ENAME	       DEPTNO
		---------- ----------
		SMITH		   20
		ALLEN		   30
		WARD		   30
		JONES		   20
		MARTIN		   30
		BLAKE		   30
		SCOTT		   20
		TURNER		   30
		ADAMS		   20
		JAMES		   30
		FORD		   20
		xiao
		12 rows selected.
		SQL> DELETE FROM d WHERE deptno=20;
		SQL> SELECT ename,deptno FROM e;		#现在e表里面的20号部门只是没有了部门号，其他的都在。
		ENAME	       DEPTNO
		---------- ----------
		SMITH
		ALLEN		   30
		WARD		   30
		JONES
		MARTIN		   30
		BLAKE		   30
		SCOTT
		TURNER		   30
		ADAMS
		JAMES		   30
		FORD
		xiao
		12 rows selected.
--------------------------------
#5  CHECK CONSTRAINT	检查约束
#作用：检查约束所在的字段必须满足check指定的条件
	SQL> DROP TABLE xs purge;
	SQL> CREATE TABLE xs (id number(10), age number(10) CONSTRAINT ck_xs_age CHECK(age>18));
	SQL> INSERT INTO xs values(1,17);		#不能插入17岁
	INSERT INTO xs values(1,17)
	*
	ERROR at line 1:
	ORA-02290: check constraint (SCOTT.CK_XS_AGE) violated
	SQL> INSERT INTO xs values(1,19);		#可以插入19岁
	SQL> INSERT INTO xs values(1,18.2);		#不能插入18.2岁，18.2四舍五入为18，不是大于18，所以不行。
	INSERT INTO xs values(1,18.2)
	*
	ERROR at line 1:
	ORA-02290: check constraint (SCOTT.CK_XS_AGE) violated
	SQL> INSERT INTO xs values(1,18.5);		#但是可以插入18.5岁，18.5四舍五入为19，大于18，所以可以。
	SQL> SELECT * FROM xs;
		ID	  AGE
	---------- ----------
		 1	   19
		 1	   19

-----------------------------------
#例子：创建e表要求如下
 Name							Null?	 Type
 ------------------------------ -------- ------------------------------------
 EMPNO	 主键					NOT NULL NUMBER(4)
 ENAME	 非空 唯一				NOT NULL VARCHAR2(10)
 JOB									 VARCHAR2(9)
 MGR	 外键 参照empno					 NUMBER(4)
 HIREDATE								 DATE
 SAL	 大于0							 NUMBER(7,2)
 COMM									 NUMBER(7,2)
 DEPTNO  参照dept的deptno				 NUMBER(2)
	SQL> CREATE TABLE e(empno number(4) CONSTRAINT pk_e_empno PRIMARY KEY,ename varchar2(10) CONSTRAINT e_ename_notnull NOT NULL CONSTRAINT un_e_ename UNIQUE,job varchar2(9),mgr number(4),hiredate date,sal number(7,2) CONSTRAINT ck_e_sal CHECK (sal>0),comm number(7,2),deptno number(2),CONSTRAINT fk_e_mgr_empno FOREIGN KEY (mgr) REFERENCES e (empno),CONSTRAINT fk_e_deptno_dept_deptno FOREIGN KEY (deptno) REFERENCES dept(deptno));
	#写好看一点
	SQL> DROP TABLE e purge;
	SQL> CREATE TABLE e (empno number(4) CONSTRAINT pk_e_empno PRIMARY KEY,
	  2  		     ename varchar2(10) CONSTRAINT e_ename_notnull NOT NULL CONSTRAINT un_e_ename UNIQUE,
	  3  		     job varchar2(9),
	  4  		     mgr number(4),					#外键一般放到最后写
	  5  		     hiredate date,
	  6  		     sal number(7,2) CONSTRAINT ck_e_sal CHECK (sal>0),
	  7  		     comm number(7,2),
	  8  		     deptno number(2),
	  9  		     CONSTRAINT fk_e_mgr_empno FOREIGN KEY (mgr) REFERENCES e (empno),
	 10  		     CONSTRAINT fk_e_deptno_dept_deptno FOREIGN KEY (deptno) REFERENCES dept(deptno));
	Table created.
	SQL> DESC e;
	 Name						Null?	 Type
	 -------------------------- -------- ------------------------------------
	 EMPNO						NOT NULL NUMBER(4)
	 ENAME						NOT NULL VARCHAR2(10)
	 JOB								 VARCHAR2(9)
	 MGR								 NUMBER(4)
	 HIREDATE							 DATE
	 SAL								 NUMBER(7,2)
	 COMM								 NUMBER(7,2)
	 DEPTNO 							 NUMBER(2)
	SQL> SELECT  CONSTRAINT_NAME,CONSTRAINT_TYPE,TABLE_NAME,DELETE_RULE
	  2  FROM user_constraints
	  3  WHERE table_name='E';
	CONSTRAINT_NAME 	       C TABLE_NAME		DELETE_RU
	-------------------------- - -------------- ---------
	E_ENAME_NOTNULL 	       C E
	CK_E_SAL				   C E
	PK_E_EMPNO				   P E
	UN_E_ENAME		           U E
	FK_E_MGR_EMPNO		       R E				NO ACTION
	FK_E_DEPTNO_DEPT_DEPTNO    R E				NO ACTION
	6 rows selected.






