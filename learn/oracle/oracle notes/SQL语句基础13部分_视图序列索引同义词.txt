视图一般分两种
	1、基本视图
	2、物化视图
什么叫做视图？
------------------------
#举例：去hr表里面
	SQL> conn hr/oracle;
	SQL> SELECT * FROM tab;
	TNAME			       TABTYPE	CLUSTERID
	---------------------- ------- ----------
	COUNTRIES		       TABLE
	DEPARTMENTS		       TABLE
	EMPLOYEES		       TABLE
	EMP_DETAILS_VIEW	   VIEW	#视图
	JOBS			       TABLE
	JOB_HISTORY		       TABLE
	LOCATIONS		       TABLE
	REGIONS 		       TABLE
	SQL> DESC EMP_DETAILS_VIEW;
	 Name						Null?	 Type
	 -------------------------  -------- -----------------
	 EMPLOYEE_ID				NOT NULL NUMBER(6)
	 JOB_ID 					NOT NULL VARCHAR2(10)
	 MANAGER_ID							 NUMBER(6)
	 DEPARTMENT_ID						 NUMBER(4)
	 LOCATION_ID						 NUMBER(4)
	 COUNTRY_ID							 CHAR(2)
	 FIRST_NAME							 VARCHAR2(20)
	 LAST_NAME					NOT NULL VARCHAR2(25)
	 SALARY 							 NUMBER(8,2)
	 COMMISSION_PCT 					 NUMBER(2,2)
	 DEPARTMENT_NAME			NOT NULL VARCHAR2(30)
	 JOB_TITLE					NOT NULL VARCHAR2(35)
	 CITY						NOT NULL VARCHAR2(30)
	 STATE_PROVINCE 					 VARCHAR2(25)
	 COUNTRY_NAME						 VARCHAR2(40)
	 REGION_NAME						 VARCHAR2(25)
----------------------------
#视图的4个用途
	限制数据访问
	简化查询
	隐藏表结构
	同一数据显示不同的视图
#视图是不存储数据（物化视图有数据，不过物化视图在OCM里面学习），存储只是一个SQL语句，真正的数据还是在表里面。（这句话一定要理解，注：在生产环境中连接查询是非常耗服务器性能的，我们作为DBA一般都会建立视图）
---------------------------
#简单的和复杂的视图
#语法：
	CREATE VIEW 视图名
	AS 
	SELECT 字段 FROM 表名（注：我们建立的视图是否复杂主要取决于select语句的复杂程度，而前面的create view 视图名 as仅仅只是固定格式）
#视图引用的表，我们称为基表
#视图分为
	简单视图：只有1张表，不能有函数，不能分组  --->  支持DML(INSERT、UPDATE、DELETE)语句
	复杂视图：多张表，有函数，可能有分组  --->  不总是可以，即有时候可以有时候不行
--------------------------
#建立一个视图，只允许查看20号部门的员工的编号，姓名，工资，部门号
	SQL> conn scott/oracle
	Connected.
	SQL> CREATE VIEW v_20
	  2  AS
	  3  SELECT empno,ename,sal,deptno
	  4  FROM emp
	  5  WHERE deptno=20;
	CREATE VIEW v_20
				*
	ERROR at line 1:
	ORA-01031: insufficient privileges		#没有权限
	SQL> conn / as sysdba
	Connected.
	SQL> GRANT CREATE VIEW TO scott;		#授予创建视图的权限
	Grant succeeded.
	SQL> conn scott/oracle;
	Connected.
	SQL> CREATE VIEW v_20		#创建视图成功
	  2  AS
	  3  SELECT empno,ename,sal,deptno
	  4  FROM emp
	  5  WHERE deptno=20;
	View created.
	SQL> SELECT * FROM tab;
	TNAME			TABTYPE	CLUSTERID
	--------------- ------- ----------
	BONUS			TABLE
	DEPT			TABLE
	E			    TABLE
	EMP			    TABLE
	SALGRADE		TABLE
	V_20			VIEW
	SQL> SELECT * FROM v_20;
		 EMPNO ENAME			 SAL    DEPTNO
	---------- ---------- ---------- ---------
		  7369 SMITH			 800		20
		  7566 JONES			2975		20
		  7788 SCOTT			3000		20
		  7876 ADAMS			1100		20
		  7902 FORD 			3000		20
----------------------------------
#视图是一个虚拟的表，那么你对表的操作就可以对视图操作
	DESC看表结构
	SELECT看内容

	SQL> DESC v_20;
	 Name					   Null?    Type
	 ----------------------------------------- -------- ----------------------------
	 EMPNO					   NOT NULL NUMBER(4)
	 ENAME						    VARCHAR2(10)
	 SAL						    NUMBER(7,2)
	 DEPTNO 					    NUMBER(2)
	SQL> SELECT * FROM v_20;
		 EMPNO ENAME			 SAL     DEPTNO
	---------- ---------- ---------- ----------
		  7369 SMITH			 800		 20
		  7566 JONES			2975		 20
		  7788 SCOTT			3000		 20
		  7876 ADAMS			1100		 20
		  7902 FORD 			3000		 20
	#这样20号部门里面的记录全部就出来了。生产环境中我们其他用户来查看数据不需要把整个E-R图搞懂，他们要看什么，我们DBA直接做个视图就好了，别人要看最好只让看视图。安全第一
----------------------------------
#增加字段
#语法：
	CREATE OR REPALCE view 视图名
	AS
	SELECT 字段 FROM 表名

	CREATE OR REPALCE 如果没有这个视图就创建，如果有则用下面的SELECT语句替换原来的视图语句
----------------------------
#增加comm字段
	SQL> CREATE OR REPLACE view v_20
	  2  AS 
	  3  SELECT comm FROM emp;
	View created.
	SQL> DESC v_20;		#只剩下comm了
	 Name					Null?    Type
	 ---------------------- -------- ----------------
	 COMM						     NUMBER(7,2)
	SQL> CREATE OR REPLACE view v_20
	  2  AS 
	  3  SELECT empno,ename,sal,comm,deptno
	  4  FROM emp
	  5  WHERE deptno=20;
	View created.
	SQL> DESC v_20;			#现在才对
	 Name					Null?    Type
	 ---------------------- -------- ----------------
	 EMPNO					NOT NULL NUMBER(4)
	 ENAME						     VARCHAR2(10)
	 SAL						     NUMBER(7,2)
	 COMM						     NUMBER(7,2)
	 DEPTNO 					     NUMBER(2)
	SQL> DESC user_views;		#视图属性
	 Name					   Null?    Type
	 ------------------------- -------- ----------------
	 VIEW_NAME				   NOT NULL VARCHAR2(30)
	 TEXT_LENGTH					    NUMBER
	 TEXT								LONG		#可以查看原始语句
	 TYPE_TEXT_LENGTH				    NUMBER
	 TYPE_TEXT							VARCHAR2(4000)
	 OID_TEXT_LENGTH				    NUMBER
	 OID_TEXT							VARCHAR2(4000)
	 VIEW_TYPE_OWNER				    VARCHAR2(30)
	 VIEW_TYPE							VARCHAR2(30)
	 SUPERVIEW_NAME 				    VARCHAR2(30)
	 EDITIONING_VIEW				    VARCHAR2(1)
	 READ_ONLY							VARCHAR2(1)
	SQL>  SELECT text FROM user_views
	  2  WHERE view_name='V_20'
	TEXT
	--------------------------------------------------------------------------------
	SELECT empno,ename,sal,comm,deptno
	FROM emp
	WHERE deptno=20
----------------------------------
#v_20是简单视图吗？是的。怎么判断简单视图：1、一张表，2、一个分组，3、没有函数  --->   可以做DML
#把20号部门工资加100
	SQL> UPDATE v_20
	  2  SET sal=sal+100;
	5 rows updated.
	SQL> SELECT * FROM v_20;
		 EMPNO ENAME	     SAL       COMM	DEPTNO
	---------- ---------- ---------- ---------- ----------
		  7369 SMITH	     900		    20
		  7566 JONES	    3075		    20
		  7788 SCOTT	    3100		    20
		  7876 ADAMS	    1200		    20
		  7902 FORD 	    3100		    20
	SQL> SELECT ename,sal,deptno FROM emp;		但是表里面的也改了
	ENAME		  SAL	  DEPTNO
	---------- ---------- ----------
	Xiaohong	 5000	      10
	SMITH		  900	      20
	ALLEN		 1600	      30
	WARD		 1250	      30
	JONES		 3075	      20
	MARTIN		 1250	      30
	BLAKE		 2850	      30
	CLARK		 2450	      10
	SCOTT		 3100	      20
	KING		 5000	      10
	TURNER		 1500	      30
	ADAMS		 1200	      20
	JAMES		  950	      30
	FORD		 3100	      20
	MILLER		 1300	      10
	15 rows selected.

	SQL> UPDATE v_20
	  2  SET sal=sal-1000
	  3  WHERE ename='SCOTT';
	1 row updated.
	SQL> SELECT * FROM v_20;
		 EMPNO ENAME	     SAL       COMM	DEPTNO
	---------- ---------- ---------- ---------- ----------
		  7369 SMITH	     900		    20
		  7566 JONES	    3075		    20
		  7788 SCOTT	    2100		    20
		  7876 ADAMS	    1200		    20
		  7902 FORD 	    3100		    20
	SQL> SELECT ename,sal,deptno FROM emp WHERE ename='SCOTT';
	ENAME		  SAL	  DEPTNO
	---------- ---------- ----------
	SCOTT		 2100	      20
-------------------------------------
#前面说的是视图只能是表的马甲，但现在不是马甲了，修改了视图就修改了基表。可以想象一下，如果这个可以改，那么建立视图就没有意义了，就算是要修改也应该对基表修改。因为视图还缺少一个属性。
	SQL> DROP view v_20;
	View dropped.
--------------------------------
#方法1：带属性:WITH CHECK OPTION
		作用：检查约束，保证视图中WHERE 语句中出现的任何字段不允许被修改
	SQL> CREATE OR REPLACE view v_20
	  2  AS
	  3  SELECT empno,ename,sal,comm,deptno
	  4  FROM emp
	  5  WHERE deptno=20
	  6  WITH CHECK OPTION;
	View created.
	SQL> SELECT * FROM v_20;
		 EMPNO ENAME	     SAL       COMM	DEPTNO
	---------- ---------- ---------- ---------- ----------
		  7369 SMITH	     900		    20
		  7566 JONES	    3075		    20
		  7788 SCOTT	    2100		    20
		  7876 ADAMS	    1200		    20
		  7902 FORD 	    3100		    20
	SQL> UPDATE v_20
	  2  SET deptno=40
	  3  WHERE ename='SCOTT';
	UPDATE v_20
		   *
	ERROR at line 1:
	ORA-01402: view WITH CHECK OPTION where-clause violation	#现在就不能修改视图了
	SQL> UPDATE v_20			#不加WHERE条件可以修改视图
	  2  SET sal=sal-1000;
	5 rows updated.
	SQL> SELECT * FROM v_20;
		 EMPNO ENAME	     SAL       COMM	DEPTNO
	---------- ---------- ---------- ---------- ----------
		  7369 SMITH	    -100		    20
		  7566 JONES	    2075		    20
		  7788 SCOTT	    1100		    20
		  7876 ADAMS	     200		    20
		  7902 FORD 	    2100		    20
	SQL> SELECT ename,sal,deptno FROM emp WHERE deptno=20;		#不加WHERE条件，基表的也被修改了
	ENAME		  SAL	  DEPTNO
	---------- ---------- ----------
	SMITH		 -100	      20
	JONES		 2075	      20
	SCOTT		 1100	      20
	ADAMS		  200	      20
	FORD		 2100	      20
-------------------------------
#一般视图的目录，就是查询，很少做操作  --->  不允许任何DML语句 --->  只读视图
#方法2：带属性:WITH READ ONLY
	SQL> CREATE OR REPLACE view v_20
	  2  AS 
	  3  SELECT empno,ename,sal,comm,deptno 
	  4  FROM emp
	  5  WHERE deptno=20
	  6  WITH READ ONLY;
	View created.
	SQL> DELETE FROM v_20;
	DELETE FROM v_20
				*
	ERROR at line 1:
	ORA-42399: cannot perform a DML operation on a read-only view		#只读的视图里面不允许执行DML语句
	SQL> UPDATE v_20
	  2  SET sal=sal-1000;
	SET sal=sal-1000
		*
	ERROR at line 2:
	ORA-42399: cannot perform a DML operation on a read-only view
	SQL> UPDATE emp
	  2  SET sal=sal+1500 
	  3  WHERE deptno=20;
	5 rows updated.
	SQL> SELECT * FROM v_20;	#修改表之后，视图也改了
		 EMPNO ENAME	     SAL       COMM		DEPTNO
	---------- ---------- ---------- ---------- ----------
		  7369 SMITH	    1400					20
		  7566 JONES	    3575					20
		  7788 SCOTT	    2600					20
		  7876 ADAMS	    1700					20
		  7902 FORD 	    3600					20
----------------------------
#删除视图
#DROP view 视图名
--------------------------------
#总结：
	视图虚拟表，不存数据，存SELECT 语句
#语法：
	CREATE OR REPLACE view 视图名字
	AS
	SELECT 字段
	FROM 表名
	WHERE 条件
	WITH READ ONLY


--------------------------------
#序列
#作用：产生一个永远不会重复的数字
#语法：
	CREATE SEQUENCE 序列名
		   [INCREMENT BY n]
		   [START WITH n]
		   [{MAXVALUE n | NOMAXVALUE}]
		   [{MINVALUE n | NOMINVALUE}]
		   [{CYCLE | NOCYCLE}]
		   [{CACHE n | NOCACHE}];
---------------------------
#添加一个序列 2 4 6 8 10，然后循环
	SQL> CREATE SEQUENCE s1			#创建序列s1
	  2			INCREMENT BY 2		#下一次增长2
	  3			START WITH 2		#以2开始
	  4			MAXVALUE 10			#最大值为10
	  5			CYCLE				#循环
	  6			NOCACHE;			#不缓存
	Sequence created.
	#创建完毕后来使用一下序列（其实就是两个伪列）
		nextval 产生下一个值
		currval 显示当前的值
	SQL> SELECT s1.nextval FROM DUAL;
	   NEXTVAL
	----------
		 2
	SQL> /
	   NEXTVAL
	----------
		 4
	SQL> /
	   NEXTVAL
	----------
		 6
	SQL> /
	   NEXTVAL
	----------
		 8
	SQL> /
	   NEXTVAL
	----------
		10
	SQL> /
	   NEXTVAL
	----------
		 1
	SQL> /
	   NEXTVAL
	----------
		 3
		#之后都是1、3、5、7、9、1、3、5、7、9，因为没有写最小值
		#注：如果不定义最小值，则默认为1
---------------------------
#能否修改？不可以定义序列下一个要显示的，如果非要规定下一个显示什么，那么必须删除重建序列
	#先删除
	SQL> DROP SEQUENCE s1;
	Sequence dropped.
	#后重建
	SQL> CREATE SEQUENCE s1
	  2  	INCREMENT BY 2
	  3  	START WITH 2
	  4  	MAXVALUE 10
	  5  	MINVALUE 2
	  6  	CYCLE
	  7   	NOCACHE;
	Sequence created.
	SQL> SELECT s1.nextval FROM DUAL;
	   NEXTVAL
	----------
		 2
	SQL> /
	   NEXTVAL
	----------
		 4
	SQL> /
	   NEXTVAL
	----------
		 6
	SQL> /
	   NEXTVAL
	----------
		 8
	SQL> /
	   NEXTVAL
	----------
		10
	SQL> /
	   NEXTVAL
	----------
		 2
		#现在就是2、4、6、8、10、2、4、6...循环
	SQL> SELECT s1.currval FROM DUAL;
	   CURRVAL
	----------
		 2
-----------------------
#建立序列2：1、2、3、......、40
	CREATE SEQUENCE s2
		   START WITH 1
		   INCREMENT BY 1
		   MINVALUE 1
		   MAXVALUE 40
		   NOCYCLE
		   NOCACHE
	#从1数到40后就不能再往后数了
	Sequence created.
	SQL> CREATE TABLE xs (id number,name varchar2(10));
	Table created.
	SQL> INSERT INTO xs (id,name) VALUES(s2.nextval,'&name');		#只需要输入姓名
	Enter value for name: tom
	old   1: INSERT INTO xs (id,name) VALUES(s2.nextval,'&name')
	new   1: INSERT INTO xs (id,name) VALUES(s2.nextval,'tom')
	SQL> SELECT * FROM xs;
			ID NAME
	---------- ----------
			 2 tom			#从2开始的，因为之前创建后就执行了一遍，所以最小值最好写0
	SQL> INSERT INTO xs (id,name) VALUES(s2.nextval,'&name');
	Enter value for name: xiao
	old   1: INSERT INTO xs (id,name) VALUES(s2.nextval,'&name')
	new   1: INSERT INTO xs (id,name) VALUES(s2.nextval,'xiao')
	1 row created.
	SQL> /
	Enter value for name: ming
	old   1: INSERT INTO xs (id,name) VALUES(s2.nextval,'&name')
	new   1: INSERT INTO xs (id,name) VALUES(s2.nextval,'ming')
	1 row created.
	SQL> SELECT * FROM xs;
			ID NAME
	---------- ----------
			 2 tom
			 3 xiao
			 4 ming
	#删除数据然后继续添加数据
	SQL> DELETE FROM xs;
	3 rows deleted.
	SQL> SELECT * FROM xs;
	no rows selected
	SQL> INSERT INTO xs (id,name) VALUES(s2.nextval,'&name');
	Enter value for name: ming
	old   1: INSERT INTO xs (id,name) VALUES(s2.nextval,'&name')
	new   1: INSERT INTO xs (id,name) VALUES(s2.nextval,'ming')
	1 row created.
	SQL> SELECT * FROM xs;
			ID NAME
	---------- ----------
			 5 ming			#从5开始，因为之前的数据是被用了，会继续自动往下计数
	SQL> rollback;
	Rollback complete.
	SQL> SELECT * FROM xs;
	no rows selected
	SQL> INSERT INTO xs (id,name) VALUES(s2.nextval,'&name');
	Enter value for name: hong;
	old   1: INSERT INTO xs (id,name) VALUES(s2.nextval,'&name')
	new   1: INSERT INTO xs (id,name) VALUES(s2.nextval,'hong;')
	1 row created.
	SQL> SELECT * FROM xs;		#事务可以回滚，但是序列不会
			ID NAME
	---------- ----------
			6 hong;
-------------------------------
#序列可以删除
	INCREMENT BY
	MAXVALUE
	MINVALUE
	CYCLE
	CACHE
	不能修改START WITH
------------------------------
#删除序列
	DROP SEQUENCE 序列名;


--------------------------------------
#INDEXES索引		#注：在性能优化的时候能不加索引就不要加索引，索引很占资源
#目的：提高查询效率
#索引：里面存储的至少有关键字和指针（行物理地址）
-------------------------
#扩展知识：
#一个SELECT执行路径有多种
	1、给予ROWID的查询    rowid 行的物理地址
	2、基于索引的扫描
	3、全表扫描
-------------------------
#预备知识：
#怎么查看一个SQL语句的执行路径（执行计划）
	1、图形
	2、explain
	3、autotace
-------------------------
#比较常见的看执行计划的例子：
	#在em下面
--------------------
	SQL> conn / as sysdba
	SQL> SET AUTOT ON	#先开执行计划
	SQL> SELECT empno,sal
	  2  FROM scott.emp
	  3  WHERE empno='7788';
		 EMPNO	  SAL
	---------- ----------
		  7788	 2600

	Execution Plan
	----------------------------------------------------------
	Plan hash value: 2949544139
	--------------------------------------------------------------------------------------
	| Id  | Operation					| Name   | Rows  | Bytes | Cost (%CPU)| Time     |
	--------------------------------------------------------------------------------------
	|   0 | SELECT STATEMENT			|	     |	   1 |	   8 |	   1   (0)| 00:00:01 |
	|   1 |  TABLE ACCESS BY INDEX ROWID| EMP    |	   1 |	   8 |	   1   (0)| 00:00:01 |		#使用的是索引
	|*  2 |   INDEX UNIQUE SCAN			| PK_EMP |	   1 |	     |	   0   (0)| 00:00:01 |
	--------------------------------------------------------------------------------------
	Predicate Information (identified by operation id):				#开销是1+1+0=2
	---------------------------------------------------
	   2 - access("EMPNO"=7788)
	Statistics
	----------------------------------------------------------
		  1  recursive calls
		  0  db block gets
		  2  consistent gets
		  0  physical reads
		  0  redo size
		592  bytes sent via SQL*Net to client
		523  bytes received via SQL*Net from client
		  2  SQL*Net roundtrips to/from client
		  0  sorts (memory)
		  0  sorts (disk)
		  1  rows processed
#求scott的工资和姓名
	#1、基于rowid
	SQL> SELECT rowid,ename FROM scott.emp;
	ROWID		   ENAME
	------------------ ----------
	AAAR3xAAEAAAACWAAA Xiaohong
	AAAR3xAAEAAAACXAAA SMITH
	AAAR3xAAEAAAACXAAB ALLEN
	AAAR3xAAEAAAACXAAC WARD
	AAAR3xAAEAAAACXAAD JONES
	AAAR3xAAEAAAACXAAE MARTIN
	AAAR3xAAEAAAACXAAF BLAKE
	AAAR3xAAEAAAACXAAG CLARK
	AAAR3xAAEAAAACXAAH SCOTT
	AAAR3xAAEAAAACXAAI KING
	AAAR3xAAEAAAACXAAJ TURNER
	AAAR3xAAEAAAACXAAK ADAMS
	AAAR3xAAEAAAACXAAL JAMES
	AAAR3xAAEAAAACXAAM FORD
	AAAR3xAAEAAAACXAAN MILLER
	15 rows selected.

	Execution Plan
	----------------------------------------------------------
	Plan hash value: 3956160932
	--------------------------------------------------------------------------
	| Id  | Operation			| Name | Rows  | Bytes | Cost (%CPU)| Time	 |
	--------------------------------------------------------------------------
	|   0 | SELECT STATEMENT	|	   |    15 |   285 |     3   (0)| 00:00:01 |
	|   1 |  TABLE ACCESS FULL	| EMP  |    15 |   285 |     3   (0)| 00:00:01 |		#使用的是全表扫描查询
	--------------------------------------------------------------------------
	Statistics											#全表扫描开销是3+3=6
	----------------------------------------------------------
		  1  recursive calls
		  0  db block gets
		  8  consistent gets
		  0  physical reads
		  0  redo size
		   1051  bytes sent via SQL*Net to client
		523  bytes received via SQL*Net from client
		  2  SQL*Net roundtrips to/from client
		  0  sorts (memory)
		  0  sorts (disk)
		 15  rows processed
	SQL> SELECT ename,sal FROM scott.emp WHERE rowid='AAAR3xAAEAAAACXAAH';
	ENAME		  SAL
	---------- ----------
	SCOTT		 2600

	Execution Plan
	----------------------------------------------------------
	Plan hash value: 1116584662
	-----------------------------------------------------------------------------------
	| Id  | Operation					| Name | Rows  | Bytes | Cost (%CPU)| Time	  |
	-----------------------------------------------------------------------------------
	|   0 | SELECT STATEMENT			|	   |	1  |    23 |	1   (0)| 00:00:01 |
	|   1 |  TABLE ACCESS BY USER ROWID | EMP  |	1  |    23 |	1   (0)| 00:00:01 |			#没有使用索引，使用的是rowid
	-----------------------------------------------------------------------------------
																#开销是1+1=2，但是不可能每次都这样写
	#常见做法：可以把你搜索的条件，比如通过姓名查找 ename和rowid 按照姓名排序  存储
	ename	rowid
	a
	b
	c
	...
	scott	AAAR3xAAEAAAACXAAH
	#当你的rowid自动更新，你增加删除性能，重新排序--->索引 ---> 为搜索的时候可以用过关键字 ---> 再去定位rowid ---> 通过rowid定位行
------------------------
#创建索引
CREATE INDEX 索引名字 ON 表名(字段名)
	SQL> CREATE INDEX ix_name1 on scott.emp(ename);
	SQL> SELECT ename,sal
	  2  FROM scott.emp
	  3  WHERE ename='SCOTT';
	ENAME		  SAL
	---------- ----------
	SCOTT		 2600

	Execution Plan
	----------------------------------------------------------
	Plan hash value: 3010727731
	----------------------------------------------------------------------------------------
	| Id  | Operation					| Name     | Rows  | Bytes | Cost (%CPU)| Time     |
	----------------------------------------------------------------------------------------
	|   0 | SELECT STATEMENT			|	       |     1 |    11 |     2	 (0)| 00:00:01 |
	|   1 |  TABLE ACCESS BY INDEX ROWID| EMP      |     1 |    11 |     2	 (0)| 00:00:01 |
	|*  2 |   INDEX RANGE SCAN			| IX_NAME1 |     1 |       |     1	 (0)| 00:00:01 |
	----------------------------------------------------------------------------------------
	Predicate Information (identified by operation id):				#可以看到用索引找人开销还是很大2+2+1=5
	---------------------------------------------------
	   2 - access("ENAME"='SCOTT')
---------------------------
#什么时候建立索引
	1、你的字段值非常多
	2、数据量非常大，有很大一部门空
	3、字段经常出现在WHERE或者JOIN ON条件里面
	4、表很大，但是你的返回数据很小，一般低于2%-4%
-------------------------
#什么时候不能建立索引
	1、表非常小，但是你返回大量的数据
	2、值非常少（比如男女）
	3、你的表发生更新
	4、字段在表达式一部分
------------------------------
#删除索引
	DROP INDEX 索引名;


---------------------------------
#同义词：给对象取一个可选的名字
----------------------
#要所有的人都可以查询scott.dept表，而且要用SELECT * FROM dept;
	SQL> SET AUTOT OFF
	SQL> SELECT * FROM scott.dept;			#在sys用户下要使用SELECT * FROM scott.dept这种方式来查
		DEPTNO DNAME	  LOC
	---------- -------------- -------------
		10 ACCOUNTING	  NEW YORK
		20 RESEARCH	  DALLAS
		30 SALES	  CHICAGO
		40 OPERATIONS	  BOSTON
	SQL> conn scott/oracle
	Connected.
	SQL> SELECT * FROM dept;			#scott用户使用的是SELECT * FROM dept
		DEPTNO DNAME	  LOC
	---------- -------------- -------------
		10 ACCOUNTING	  NEW YORK
		20 RESEARCH		DALLAS
		30 SALES		CHICAGO
		40 OPERATIONS	  BOSTON
	SQL> conn hr/oracle			#到hr用户
	Connected.
	SQL> SELECT * FROM dept;	#没有这个表
	SELECT * FROM dept
				  *
	ERROR at line 1:
	ORA-00942: table or view does not exist
	#一个用户要访问另一个用户的对象，必须对方的对象拥有者 作为前缀
	SQL> SELECT * FROM scott.dept;
	SELECT * FROM scott.dept
						*
	ERROR at line 1:
	ORA-00942: table or view does not exist
	#说明hr没有权限访问scott.dept表
	#授权
	SQL> conn scott/oracle
	Connected.
	SQL> GRANT SELECT ON dept TO hr;
	Grant succeeded.
	SQL> conn hr/oracle
	Connected.
	SQL> SELECT * FROM scott.dept;
		DEPTNO DNAME	  LOC
	---------- -------------- -------------
		10 ACCOUNTING	  NEW YORK
		20 RESEARCH	  DALLAS
		30 SALES	  CHICAGO
		40 OPERATIONS	  BOSTON
	SQL> SELECT * FROM dept;
	SELECT * FROM dept
				  *
	ERROR at line 1:
	ORA-00942: table or view does not exist
	#使用SELECT * FROM dept;还是不行
-------------------------
#所有人都可以使用SELECT * FROM dept;  --->  scott.dept表的内容
#步骤：
	1、授予所有人都可以对scott.dept有SELECT权限
	2、建立一个公共同义词  scott.dept取名为dept
------------------------
#分类：
	私有同义词：只有建立者可以使用
		CREATE SYNONYM 私有同义词名
		FOR 对象;
	公共同义词：所有人都可以使用
		CREATE PUBLIC SYNONYM 公共同义词名
		FOR 对象;
------------------------
#授予所有人都可以对scott.dept有SELECT权限
	SQL> conn / as sysdba
	Connected.
	SQL> GRANT SELECT ON scott.dept TO PUBLIC;
	Grant succeeded.
#建立一个公共同义词		scott.dept 取名dept
	SQL> CREATE PUBLIC SYNONYM dept FOR scott.dept;
	Synonym created.

	SQL> SELECT * FROM dept;
		DEPTNO DNAME	  LOC
	---------- -------------- -------------
		10 ACCOUNTING	  NEW YORK
		20 RESEARCH	  DALLAS
		30 SALES	  CHICAGO
		40 OPERATIONS	  BOSTON
	SQL> SHOW USER;
	USER is "SYS"
	SQL> conn hr/oracle
	Connected.
	SQL> SELECT * FROM dept;
		DEPTNO DNAME	  LOC
	---------- -------------- -------------
		10 ACCOUNTING	  NEW YORK
		20 RESEARCH	  DALLAS
		30 SALES	  CHICAGO
		40 OPERATIONS	  BOSTON

	SQL> conn / as sysdba
	Connected.
	SQL> DESC dba_synonyms;
	 Name						 Null?	  Type
	 ----------------------------------------------- -------- --------------------------------
	 OWNER						 NOT NULL VARCHAR2(30)
	 SYNONYM_NAME					 NOT NULL VARCHAR2(30)
	 TABLE_OWNER						  VARCHAR2(30)
	 TABLE_NAME					 NOT NULL VARCHAR2(30)
	 DB_LINK						  VARCHAR2(128)
	SQL> SELECT owner,synonym_name FROM dba_synonyms WHERE synonym_name='DEPT';
	OWNER			       SYNONYM_NAME
	------------------------------ ------------------------------
	PUBLIC			       DEPT
	SQL> SELECT owner,synonym_name,table_owner,table_name FROM dba_synonyms WHERE synonym_name='DEPT';
	OWNER			 SYNONYM_NAME		TABLE_OWNER		  TABLE_NAME
	---------------- ------------------ ----------------- ---------------
	PUBLIC			 DEPT				SCOTT			  DEPT

---------------------------------
#第一门SQL全部结束
#课程总结：
	1、lb.sql	select   from   where  || " &name spool set
	2、查看表空间的脚本
		函数 分组汇总 多表查询 子查询
	3、集合运算
	4、ddl 建立表	：数据类型 约束
	5、dml insert update delete trunace
		事务语句  commit rollback
	6、视图 索引 序列 同义词









