#操作大型数据集
#子查询作用
	1、通过使用内嵌视图检索数据
		SELECT ename,sal FROM emp
		WHERE sal>(SELECT sal FROM scott.emp WHERE ename='SCOTT');
	2、从一个表的数据复制到另一个
		INSERT INTO scott.emp
		SELECT * FROM scott.emp;
	3、更新表中的数据基于另一个表中的值
		把销售部门员工的工资加1000
		UPDATE scott.emp
		SET sal=sal+1000
		WHERE deptno=(SELECT deptno FROM dept WHERE dname='SALES');
	4、从一个表基于另一个表中的行，删除行
		删除销售部门的员工
		DELETE FROM scott.emp
		WHERE deptno=(SELECT deptno FROM scott.dept WHERE dname='SALES');
	子查询做表用，我们看一个例子就好
		SELECT department_name,city
		FROM departments
		NATURAL JOIN (SELECT l.location_id,l.city,l.country_id
					  FROM loc l
					  JOIN countries c
					  ON (l.country_id=c.country_id)
					  JOIN regions USING (region_id)
					  WHERE region_name='Europe');
	子查询归档插入范围 
		CREATE TABLE e AS SELECT * FROM scott.emp WHERE 1=2;
		假设e员工总表
			10号部门hr只能插入10号员工的信息（只能插入empno，ename，sal，deptno，其他字段没有插入权限）
			20号部门hr只能插入20号员工的信息（只能插入empno，ename，sal，deptno，其他字段没有插入权限）
		INSERT INTO (SELECT empno,ename,sal,deptno
					 FROM e WHERE deptno=10 WITH CHECK OPTION)
		values(1,'tom',1000,10);
		1 row created.	
		INSERT INTO (SELECT empno,ename,sal,deptno
					 FROM e WHERE deptno=10 WITH CHECK OPTION)
		values(1,'tom',1000,20);
					 FROM e WHERE deptno=10 WITH CHECK OPTION)
					      *
		ERROR at line 2:
		ORA-01402: view WITH CHECK OPTION where-clause violation	#20号部门插入就错了
		#那么这个最终目的就是用子查询限定一个最终插入条件

------------------------------
#多表插入
	INSERT ALL
		INTO target_a VALUES(...,...,...)
		INTO target_b VALUES(...,...,...)
		INTO target_c VALUES(...,...,...)
		SELECT ...
		FROM sourcetab
		WHERE ...;
--------------------------
#创建实验用表
	CREATE TABLE e10 AS SELECT empno,ename,sal,deptno FROM emp WHERE 1=2;
	CREATE TABLE e20 AS SELECT empno,ename,sal,deptno FROM emp WHERE 1=2;
	CREATE TABLE e30 AS SELECT empno,ename,sal,deptno FROM emp WHERE 1=2;
#有一个表emp表有14条数据，存储10 20 30 部门的信息
#要求：从emp表中检索数据插入e10 e20 e30
#开始是这样想的:
	INSERT INTO e10 SELECT empno,ename,sal,deptno FROM emp WHERE deptno=10;
	COMMIT;
	INSERT INTO e20 SELECT empno,ename,sal,deptno FROM emp WHERE deptno=20;
	COMMIT;
	INSERT INTO e30 SELECT empno,ename,sal,deptno FROM emp WHERE deptno=30;
	COMMIT;
#可能刚开始是这样想的，可是如果有更多的表要插入怎么办，而且插入e10，e20，e30三个不同的表却访问了同一张表三次，单个DML语句这样做肯定不行，开销太大
---------------------------
#更高效的语句：
	1、无条件的
	语法：all表示所有的表都要插入
	INSERT ALL
		INTO 表名 VALUES(字段名,...)
		INTO 表名 VALUES(字段名,...)
		...
		SELECT 字段名,...
		FROM 表名
		WHERE 条件;
	#语法含义：先通过SELECT语句，然后把结果从第一个INSERT开始向下依次根据名字来插入数据，每个表都要插入
------------------------
#案例：emp存储所有员工的信息，分离两个表
		一个叫e，存储员工信息 empno,ename,sal,mgr
		一个叫m，存储领导信息 mgr,ename,sal
	CREATE TABLE e AS SELECT empno,ename,sal,mgr FROM emp WHERE 1=2;
	CREATE TABLE m AS SELECT mgr,ename,sal FROM emp WHERE 1=2;
	INSERT ALL
		INTO e VALUES(empno,ename,sal,mgr)
		INTO m VALUES(mgr,ename,sal)
		SELECT * FROM emp;
	或者
	INSERT ALL
		INTO e VALUES(empno,ename,sal,mgr)
		INTO m VALUES(mgr,ename,sal)
		SELECT empno,ename,sal,mgr FROM emp;
---------------------------
	2、带条件的
	语法：
	INSERT ALL 
		WHEN 条件 THEN 
		INTO 表名 VALUES(字段名,...)
		WHEN 条件 THEN
		INTO 表名 VALUES(字段名,...)
		...
		SELECT 字段名,...
		FROM 表名
	
	10 20 30号插入到e10 e20 e30
	INSERT ALL
		WHEN deptno=10 THEN
		INTO e10 VALUES(empno,ename,sal,deptno)
		WHEN deptno=20 THEN
		INTO e20 VALUES(empno,ename,sal,deptno)
		WHEN deptno=30 THEN
		INTO e30 VALUES(empno,ename,sal,deptno)
		SELECT *
		FROM emp;
	COMMIT;
	SELECT * FROM e10;
	EMPNO	ENAME	SAL	DEPTNO
	--------- --------- -------- ---------
	7782	CLARK	2450	10
	7839	KING	5000	10
	7934	MILLER	1300	10
---------------------------
	3、有条件的插入第一个
	语法：
	INSERT FIRST
		WHEN 条件 THEN
		INTO 表名 VALUES(字段名,...)
		WHEN 条件 THEN
		INTO 表名 VALUES(字段名,...)
		...
		SELECT 字段名,...
		FROM 表名;
	#first从上向下找条件，如果条件满足后，记录不再插入后面的表，就是只要我满足第一个，剩下的就不管了


































































